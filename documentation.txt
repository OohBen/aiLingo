Title: Intro
Content:
Django Ninja
Skip to content
Django Ninja
Intro
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Intro
Table of contents
Installation
Quick Example
Check it
Interactive API docs
Recap
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Installation
Quick Example
Check it
Interactive API docs
Recap
Django Ninja - Fast Django REST Framework
RUSSIA INVADED UKRAINE -
Please read
Django Ninja is a web framework for building APIs with Django and Python 3.6+ type hints.
Key features:
Easy
: Designed to be easy to use and intuitive.
FAST execution
: Very high performance thanks to
Pydantic
and
async support
.
Fast to code
: Type hints and automatic docs lets you focus only on business logic.
Standards-based
: Based on the open standards for APIs:
OpenAPI
(previously known as Swagger) and
JSON Schema
.
Django friendly
: (obviously) has good integration with the Django core and ORM.
Production ready
: Used by multiple companies on live projects (If you use Django Ninja and would like to publish your feedback, please email ppr.vitaly@gmail.com).
Benchmarks
:
Installation
pip install django-ninja
Quick Example
Start a new Django project (or use an existing one)
django-admin startproject apidemo
in
urls.py
from
django.contrib
import
admin
from
django.urls
import
path
from
ninja
import
NinjaAPI
api
=
NinjaAPI
()
@api
.
get
(
"/add"
)
def
add
(
request
,
a
:
int
,
b
:
int
):
return
{
"result"
:
a
+
b
}
urlpatterns
=
[
path
(
"admin/"
,
admin
.
site
.
urls
),
path
(
"api/"
,
api
.
urls
),
]
Now, run it as usual:
./manage.py runserver
Note: You don't have to add Django Ninja to your installed apps for it to work.
Check it
Open your browser at
http://127.0.0.1:8000/api/add?a=1&b=2
You will see the JSON response as:
{
"result"
:
3
}
Now you've just created an API that:
receives an HTTP GET request at
/api/add
takes, validates and type-casts GET parameters
a
and
b
decodes the result to JSON
generates an OpenAPI schema for defined operation
Interactive API docs
Now go to
http://127.0.0.1:8000/api/docs
You will see the automatic, interactive API documentation (provided by the
OpenAPI / Swagger UI
or
Redoc
):
Recap
In summary, you declare the types of parameters, body, etc.
once only
, as function parameters.
You do that with standard modern Python types.
You don't have to learn a new syntax, the methods or classes of a specific library, etc.
Just standard
Python 3.6+
.
For example, for an
int
:
a
:
int
or, for a more complex
Item
model:
class
Item
(
Schema
):
foo
:
str
bar
:
float
def
operation
(
a
:
Item
):
...
... and with that single declaration you get:
Editor support, including:
Completion
Type checks
Validation of data:
Automatic and clear errors when the data is invalid
Validation, even for deeply nested JSON objects
Conversion
of input data coming from the network, to Python data and types, and reading from:
JSON
Path parameters
Query parameters
Cookies
Headers
Forms
Files
Automatic, interactive API documentation
This project was heavily inspired by
FastAPI
(developed by
Sebastián Ramírez
)
Next
Motivation
Made with
Material for MkDocs
----------------------------------------
Title: Motivation
Content:
Motivation - Django Ninja
Skip to content
Django Ninja
Motivation
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Motivation
Table of contents
Django Ninja
Main Features
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Django Ninja
Main Features
Motivation
Quote
Django Ninja
looks basically the same as
FastAPI
, so why not just use FastAPI?
Indeed,
Django Ninja
is heavily inspired by
FastAPI
(developed by
Sebastián Ramírez
)
That said, there are few issues when it comes to getting FastAPI and Django to work together properly:
1)
FastAPI
declares to be ORM agnostic (meaning you can use it with SQLAlchemy or the Django ORM), but in reality the Django ORM is not yet ready for async use (it may be in version 4.0 or 4.1), and if you use it in sync mode, you can have a
closed connection issue
which you will have to overcome with a
lot
of effort.
2) The dependency injection with arguments makes your code too verbose when you rely on authentication and database sessions in your operations (which for some projects is about 99% of all operations).
...
app
=
FastAPI
()
# Dependency
def
get_db
():
db
=
SessionLocal
()
try
:
yield
db
finally
:
db
.
close
()
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
decode
(
token
)
if
not
user
:
raise
HTTPException
(
...
)
return
user
@app
.
get
(
"/task/
{task_id}
"
,
response_model
=
Task
)
def
read_user
(
task_id
:
int
,
db
:
Session
=
Depends
(
get_db
),
current_user
:
User
=
Depends
(
get_current_user
),
):
...
use
db
with
current_user
....
3) Since the word
model
in Django is "reserved" for use by the ORM, it becomes very confusing when you mix the Django ORM with Pydantic/FastAPI model naming conventions.
Django Ninja
Django Ninja addresses all those issues, and integrates very well with Django (ORM, urls, views, auth and more)
Working at
Code-on a Django webdesign webedevelopment studio
I get all sorts of challenges and to solve these I started Django-Ninja in 2020.
Note:
Django Ninja is a production ready project
- my estimation is at this time already 100+ companies using it in production and 500 new developers joining every month.
Some companies are already looking for developers with django ninja experience.
Main Features
1) Since you can have multiple Django Ninja API instances - you can run
multiple API versions
inside one Django project.
api_v1
=
NinjaAPI
(
version
=
'1.0'
,
auth
=
token_auth
)
...
api_v2
=
NinjaAPI
(
version
=
'2.0'
,
auth
=
token_auth
)
...
api_private
=
NinjaAPI
(
auth
=
session_auth
,
urls_namespace
=
'private_api'
)
...
urlpatterns
=
[
...
path
(
'api/v1/'
,
api_v1
.
urls
),
path
(
'api/v2/'
,
api_v2
.
urls
),
path
(
'internal-api/'
,
api_private
.
urls
),
]
2) The Django Ninja 'Schema' class is integrated with the ORM, so you can
serialize querysets
or ORM objects:
@api
.
get
(
"/tasks"
,
response
=
List
[
TaskSchema
])
def
tasks
(
request
):
return
Task
.
objects
.
all
()
@api
.
get
(
"/tasks"
,
response
=
TaskSchema
)
def
tasks_details
(
request
):
task
=
Task
.
objects
.
first
()
return
task
3)
Create Schema's from Django Models
.
4) Instead of dependency arguments,
Django Ninja
uses
request
instance attributes (in the same way as regular Django views) - more detail at
Authentication
.
Previous
Intro
Next
First Steps
Made with
Material for MkDocs
----------------------------------------
Title: First Steps
Content:
First Steps - Django Ninja
Skip to content
Django Ninja
First Steps
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
First Steps
Table of contents
Installation
Create a Django project
Create the API
Our first operation
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Installation
Create a Django project
Create the API
Our first operation
Tutorial - First Steps
This tutorial shows you how to use
Django Ninja
with most of its features.
This tutorial assumes that you know at least some basics of the
Django Framework
, like how to create a project and run it.
Installation
pip install django-ninja
Note
It is not required, but you can also put
ninja
to
INSTALLED_APPS
.
In that case the OpenAPI/Swagger UI (or Redoc) will be loaded (faster) from the included JavaScript bundle (otherwise the JavaScript bundle comes from a CDN).
Create a Django project
Start a new Django project (or if you already have an existing Django project, skip to the next step).
django-admin startproject myproject
Create the API
Let's create a module for our API. Create an
api.py
file in the same directory location as your Django project's root
urls.py
:
from
ninja
import
NinjaAPI
api
=
NinjaAPI
()
Now go to
urls.py
and add the following:
from
django.contrib
import
admin
from
django.urls
import
path
from
.api
import
api
urlpatterns
=
[
path
(
"admin/"
,
admin
.
site
.
urls
),
path
(
"api/"
,
api
.
urls
),
]
Our first operation
Django Ninja
comes with a decorator for each HTTP method (
GET
,
POST
,
PUT
, etc). In our
api.py
file, let's add in a simple "hello world"
operation.
from
ninja
import
NinjaAPI
api
=
NinjaAPI
()
@api
.
get
(
"/hello"
)
def
hello
(
request
):
return
"Hello world"
Now browsing to
localhost:8000/api/hello
will return a simple JSON
response:
"Hello world"
Success
Continue on to
Parsing input
.
Previous
Motivation
Next
Parsing Input
Made with
Material for MkDocs
----------------------------------------
Title: Parsing Input
Content:
Parsing Input - Django Ninja
Skip to content
Django Ninja
Parsing Input
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Parsing Input
Table of contents
Input from the query string
Defaults
Input types
Input from the path
Input from the request body
Self-documenting API
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Input from the query string
Defaults
Input types
Input from the path
Input from the request body
Self-documenting API
Tutorial - Parsing Input
Input from the query string
Let's change our operation to accept a name from the URL's query string. To do that, just add a
name
argument to our function.
@api
.
get
(
"/hello"
)
def
hello
(
request
,
name
):
return
f
"Hello
{
name
}
"
When we provide a name argument, we get the expected (HTTP 200) response.
localhost:8000/api/hello?name=you
:
"Hello you"
Defaults
Not providing the argument will return an
HTTP 422
error response.
localhost:8000/api/hello
:
{
"detail"
:
[
{
"loc"
:
[
"query"
,
"name"
],
"msg"
:
"field required"
,
"type"
:
"value_error.missing"
}
]
}
We can specify a default for the
name
argument in case it isn't provided:
@api
.
get
(
"/hello"
)
def
hello
(
request
,
name
=
"world"
):
return
f
"Hello
{
name
}
"
Input types
Django Ninja
uses standard
Python type hints
to format the input types. If no type is provided then a string is assumed (but it is good practice to provide type hints for all your arguments).
Let's add a second operation that does some basic math with integers.
@api
.
get
(
"/hello"
)
def
hello
(
request
,
name
:
str
=
"world"
):
return
f
"Hello
{
name
}
"
@api
.
get
(
"/math"
)
def
math
(
request
,
a
:
int
,
b
:
int
):
return
{
"add"
:
a
+
b
,
"multiply"
:
a
*
b
}
localhost:8000/api/math?a=2&b=3
:
{
"add"
:
5
,
"multiply"
:
6
}
Input from the path
You can declare path "parameters" with the same syntax used by Python format-strings.
Any parameters found in the path string will be passed to your function as arguments, rather than expecting them from the query string.
@api
.
get
(
"/math/
{a}
and
{b}
"
)
def
math
(
request
,
a
:
int
,
b
:
int
):
return
{
"add"
:
a
+
b
,
"multiply"
:
a
*
b
}
Now we access the math operation from
localhost:8000/api/math/2and3
.
Input from the request body
We are going to change our
hello
operation to use HTTP
POST
instead, and take arguments from the request body.
To specify that arguments come from the body, we need to declare a
Schema
.
from
ninja
import
NinjaAPI
,
Schema
api
=
NinjaAPI
()
class
HelloSchema
(
Schema
):
name
:
str
=
"world"
@api
.
post
(
"/hello"
)
def
hello
(
request
,
data
:
HelloSchema
):
return
f
"Hello
{
data
.
name
}
"
Self-documenting API
Accessing
localhost:8000/api/hello
now results in a
HTTP 405
error response, since we need to POST to this URL instead.
An easy way to do this is to use the Swagger documentation that is automatically created for us, at default URL of "/docs" (appended to our API url root).
Visit
localhost:8000/api/docs
to see the operations we have created
Open the
/api/hello
operation
Click "Try it out"
Change the request body
Click "Execute"
Success
Continue on to
Handling responses
Previous
First Steps
Next
Handling Responses
Made with
Material for MkDocs
----------------------------------------
Title: Handling Responses
Content:
Handling Responses - Django Ninja
Skip to content
Django Ninja
Handling Responses
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Handling Responses
Table of contents
Define a response Schema
Multiple response types
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Define a response Schema
Multiple response types
Tutorial - Handling Responses
Define a response Schema
Django Ninja
allows you to define the schema of your responses both for validation and documentation purposes.
We'll create a third operation that will return information about the current Django user.
from
ninja
import
Schema
class
UserSchema
(
Schema
):
username
:
str
is_authenticated
:
bool
# Unauthenticated users don't have the following fields, so provide defaults.
email
:
str
=
None
first_name
:
str
=
None
last_name
:
str
=
None
@api
.
get
(
"/me"
,
response
=
UserSchema
)
def
me
(
request
):
return
request
.
user
This will convert the Django
User
object into a dictionary of only the defined fields.
Multiple response types
Let's return a different response if the current user is not authenticated.
class
UserSchema
(
Schema
):
username
:
str
email
:
str
first_name
:
str
last_name
:
str
class
Error
(
Schema
):
message
:
str
@api
.
get
(
"/me"
,
response
=
{
200
:
UserSchema
,
403
:
Error
})
def
me
(
request
):
if
not
request
.
user
.
is_authenticated
:
return
403
,
{
"message"
:
"Please sign in first"
}
return
request
.
user
As you see, you can return a 2-part tuple which will be interpreted as the HTTP response code and the data.
Success
That concludes the tutorial! Check out the
Other Tutorials
or the
How-to Guides
for more information.
Previous
Parsing Input
Next
Video Tutorials
Made with
Material for MkDocs
----------------------------------------
Title: Video Tutorials
Content:
Video Tutorials - Django Ninja
Skip to content
Django Ninja
Video Tutorials
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
Video Tutorials
Table of contents
Sneaky REST APIs With Django Ninja
Creating a CRUD API with Django-Ninja by BugBytes (English)
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Sneaky REST APIs With Django Ninja
Creating a CRUD API with Django-Ninja by BugBytes (English)
Video Tutorials
Sneaky REST APIs With Django Ninja
realpython.com/lessons/sneaky-rest-apis-with-django-ninja-overview/
Creating a CRUD API with Django-Ninja by BugBytes (English)
Previous
Handling Responses
Next
CRUD example
Made with
Material for MkDocs
----------------------------------------
Title: CRUD example
Content:
CRUD example - Django Ninja
Skip to content
Django Ninja
CRUD example
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
CRUD example
Table of contents
Create
Retrieve
Single object
List of objects
Update
Delete
Final code
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Create
Retrieve
Single object
List of objects
Update
Delete
Final code
CRUD example
CRUD
-
C
reate,
R
etrieve,
U
pdate,
D
elete are the four basic functions of persistent storage.
This example will show you how to implement these functions with
Django Ninja
.
Let's say you have the following Django models that you need to perform these operations on:
class
Department
(
models
.
Model
):
title
=
models
.
CharField
(
max_length
=
100
)
class
Employee
(
models
.
Model
):
first_name
=
models
.
CharField
(
max_length
=
100
)
last_name
=
models
.
CharField
(
max_length
=
100
)
department
=
models
.
ForeignKey
(
Department
,
on_delete
=
models
.
CASCADE
)
birthdate
=
models
.
DateField
(
null
=
True
,
blank
=
True
)
cv
=
models
.
FileField
(
null
=
True
,
blank
=
True
)
Now let's create CRUD operations for the Employee model.
Create
To create an employee lets define an INPUT schema:
from
datetime
import
date
from
ninja
import
Schema
class
EmployeeIn
(
Schema
):
first_name
:
str
last_name
:
str
department_id
:
int
=
None
birthdate
:
date
=
None
This schema will be our input payload:
@api
.
post
(
"/employees"
)
def
create_employee
(
request
,
payload
:
EmployeeIn
):
employee
=
Employee
.
objects
.
create
(
**
payload
.
dict
())
return
{
"id"
:
employee
.
id
}
Tip
Schema
objects have
.dict()
method with all the schema attributes represented as a dict.
You can pass it as
**kwargs
to the Django model's
create
method (or model
__init__
).
See the recipe below for handling the file upload (when using Django models):
from
ninja
import
UploadedFile
,
File
@api
.
post
(
"/employees"
)
def
create_employee
(
request
,
payload
:
EmployeeIn
,
cv
:
UploadedFile
=
File
(
...
)):
payload_dict
=
payload
.
dict
()
employee
=
Employee
(
**
payload_dict
)
employee
.
cv
.
save
(
cv
.
name
,
cv
)
# will save model instance as well
return
{
"id"
:
employee
.
id
}
If you just need to handle a file upload:
from
django.core.files.storage
import
FileSystemStorage
from
ninja
import
UploadedFile
,
File
STORAGE
=
FileSystemStorage
()
@api
.
post
(
"/upload"
)
def
create_upload
(
request
,
cv
:
UploadedFile
=
File
(
...
)):
filename
=
STORAGE
.
save
(
cv
.
name
,
cv
)
# Handle things further
Retrieve
Single object
Now to get employee we will define a schema that will describe what our responses will look like. Here we will basically use the same schema as
EmployeeIn
, but will add an extra attribute
id
:
class
EmployeeOut
(
Schema
):
id
:
int
first_name
:
str
last_name
:
str
department_id
:
int
=
None
birthdate
:
date
=
None
Note
Defining response schemas are not really required, but when you do define it you will get results validation, documentation and automatic ORM objects to JSON conversions.
We will use this schema as the
response
type for our
GET
employee view:
@api
.
get
(
"/employees/
{employee_id}
"
,
response
=
EmployeeOut
)
def
get_employee
(
request
,
employee_id
:
int
):
employee
=
get_object_or_404
(
Employee
,
id
=
employee_id
)
return
employee
Notice that we simply returned an employee ORM object, without a need to convert it to a dict. The
response
schema does automatic result validation and conversion to JSON:
@api
.
get
(
"/employees/
{employee_id}
"
,
response
=
EmployeeOut
)
def
get_employee
(
request
,
employee_id
:
int
):
employee
=
get_object_or_404
(
Employee
,
id
=
employee_id
)
return
employee
List of objects
To output a list of employees, we can reuse the same
EmployeeOut
schema. We will just set the
response
schema to a
List
of
EmployeeOut
.
from
typing
import
List
@api
.
get
(
"/employees"
,
response
=
List
[
EmployeeOut
])
def
list_employees
(
request
):
qs
=
Employee
.
objects
.
all
()
return
qs
Another cool trick - notice we just returned a Django ORM queryset:
@api
.
get
(
"/employees"
,
response
=
List
[
EmployeeOut
])
def
list_employees
(
request
):
qs
=
Employee
.
objects
.
all
()
return
qs
It automatically gets evaluated, validated and converted to a JSON list!
Update
Update is pretty trivial. We just use the
PUT
method and also pass
employee_id
:
@api
.
put
(
"/employees/
{employee_id}
"
)
def
update_employee
(
request
,
employee_id
:
int
,
payload
:
EmployeeIn
):
employee
=
get_object_or_404
(
Employee
,
id
=
employee_id
)
for
attr
,
value
in
payload
.
dict
()
.
items
():
setattr
(
employee
,
attr
,
value
)
employee
.
save
()
return
{
"success"
:
True
}
Note
Here we used the
payload.dict
method to set all object attributes:
for attr, value in payload.dict().items()
You can also do this more explicit:
employee
.
first_name
=
payload
.
first_name
employee
.
last_name
=
payload
.
last_name
employee
.
department_id
=
payload
.
department_id
employee
.
birthdate
=
payload
.
birthdate
Partial updates
To allow the user to make partial updates, use
payload.dict(exclude_unset=True).items()
. This ensures that only the specified fields get updated.
Enforcing strict field validation
By default, any provided fields that don't exist in the schema will be silently ignored. To raise an error for these invalid fields, you can set
extra = "forbid"
in the schema's Config class. For example:
class
EmployeeIn
(
Schema
):
# your fields here...
class
Config
:
extra
=
"forbid"
Delete
Delete is also pretty simple. We just get employee by
id
and delete it from the DB:
@api
.
delete
(
"/employees/
{employee_id}
"
)
def
delete_employee
(
request
,
employee_id
:
int
):
employee
=
get_object_or_404
(
Employee
,
id
=
employee_id
)
employee
.
delete
()
return
{
"success"
:
True
}
Final code
Here's a full CRUD example:
from
datetime
import
date
from
typing
import
List
from
ninja
import
NinjaAPI
,
Schema
from
django.shortcuts
import
get_object_or_404
from
employees.models
import
Employee
api
=
NinjaAPI
()
class
EmployeeIn
(
Schema
):
first_name
:
str
last_name
:
str
department_id
:
int
=
None
birthdate
:
date
=
None
class
EmployeeOut
(
Schema
):
id
:
int
first_name
:
str
last_name
:
str
department_id
:
int
=
None
birthdate
:
date
=
None
@api
.
post
(
"/employees"
)
def
create_employee
(
request
,
payload
:
EmployeeIn
):
employee
=
Employee
.
objects
.
create
(
**
payload
.
dict
())
return
{
"id"
:
employee
.
id
}
@api
.
get
(
"/employees/
{employee_id}
"
,
response
=
EmployeeOut
)
def
get_employee
(
request
,
employee_id
:
int
):
employee
=
get_object_or_404
(
Employee
,
id
=
employee_id
)
return
employee
@api
.
get
(
"/employees"
,
response
=
List
[
EmployeeOut
])
def
list_employees
(
request
):
qs
=
Employee
.
objects
.
all
()
return
qs
@api
.
put
(
"/employees/
{employee_id}
"
)
def
update_employee
(
request
,
employee_id
:
int
,
payload
:
EmployeeIn
):
employee
=
get_object_or_404
(
Employee
,
id
=
employee_id
)
for
attr
,
value
in
payload
.
dict
()
.
items
():
setattr
(
employee
,
attr
,
value
)
employee
.
save
()
return
{
"success"
:
True
}
@api
.
delete
(
"/employees/
{employee_id}
"
)
def
delete_employee
(
request
,
employee_id
:
int
):
employee
=
get_object_or_404
(
Employee
,
id
=
employee_id
)
employee
.
delete
()
return
{
"success"
:
True
}
Previous
Video Tutorials
Next
HTTP Methods
Made with
Material for MkDocs
----------------------------------------
Title: HTTP Methods
Content:
HTTP Methods - Django Ninja
Skip to content
Django Ninja
HTTP Methods
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
HTTP Methods
Table of contents
Defining operations
Handling multiple methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Defining operations
Handling multiple methods
HTTP Methods
Defining operations
An "Operation" can be one of the HTTP "methods":
GET
POST
PUT
DELETE
PATCH
... and more
Django Ninja
comes with a decorator for each operation:
@api
.
get
(
"/path"
)
def
get_operation
(
request
):
...
@api
.
post
(
"/path"
)
def
post_operation
(
request
):
...
@api
.
put
(
"/path"
)
def
put_operation
(
request
):
...
@api
.
delete
(
"/path"
)
def
delete_operation
(
request
):
...
@api
.
patch
(
"/path"
)
def
patch_operation
(
request
):
...
See the
Operations parameters
reference docs for information on what you can pass to any of these decorators.
Handling multiple methods
If you need to handle multiple methods with a single function for a given path,
you can use the
api_operation
decorator:
@api
.
api_operation
([
"POST"
,
"PATCH"
],
"/path"
)
def
mixed
(
request
):
...
This feature can also be used to implement other HTTP methods that don't have
corresponding django-ninja methods, such as
HEAD
or
OPTIONS
.
@api
.
api_operation
([
"HEAD"
,
"OPTIONS"
],
"/path"
)
def
mixed
(
request
):
...
Previous
CRUD example
Next
Path parameters
Made with
Material for MkDocs
----------------------------------------
Title: Path parameters
Content:
Path parameters - Django Ninja
Skip to content
Django Ninja
Path parameters
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Path parameters
Table of contents
Path parameters with types
Data validation
Django Path Converters
Path params with slashes
Multiple parameters
Using Schema
Documentation
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Path parameters with types
Data validation
Django Path Converters
Path params with slashes
Multiple parameters
Using Schema
Documentation
Path parameters
You can declare path "parameters" with the same syntax used by Python format-strings (which luckily also matches the
OpenAPI path parameters
):
@api
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
request
,
item_id
):
return
{
"item_id"
:
item_id
}
The value of the path parameter
item_id
will be passed to your function as the argument
item_id
.
So, if you run this example and go to
http://localhost:8000/api/items/foo
, you will see this response:
{
"item_id"
:
"foo"
}
Path parameters with types
You can declare the type of path parameter in the function using standard Python type annotations:
@api
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
request
,
item_id
:
int
):
return
{
"item_id"
:
item_id
}
In this case,
item_id
is declared to be an
int
. This will give you editor and linter support for error checks, completion, etc.
If you run this in your browser with
http://localhost:8000/api/items/3
, you will see this response:
{
"item_id"
:
3
}
Tip
Notice that the value your function received (and returned) is
3
, as a Python
int
- not a string
"3"
.
So, with just that type declaration,
Django Ninja
gives you automatic request "parsing" and validation.
Data validation
On the other hand, if you go to the browser at
http://localhost:8000/api/items/foo
(
"foo"
is not int)
, you will see an HTTP error like this:
{
"detail"
:
[
{
"loc"
:
[
"path"
,
"item_id"
],
"msg"
:
"value is not a valid integer"
,
"type"
:
"type_error.integer"
}
]
}
Django Path Converters
You can use
Django Path Converters
to help parse the path:
@api
.
get
(
"/items/{int:item_id}"
)
def
read_item
(
request
,
item_id
):
return
{
"item_id"
:
item_id
}
In this case,
item_id
will be parsed as an
int
. If
item_id
is not a valid
int
, the url will not
match.  (e.g. if no other path matches, a
404 Not Found
will be returned)
Tip
Notice that, since
Django Ninja
uses a default type of
str
for unannotated parameters, the value the
function above received (and returned) is
"3"
, as a Python
str
- not an integer
3
. To receive
an
int
, simply declare
item_id
as an
int
type annotation in the function definition as normal:
@api
.
get
(
"/items/{int:item_id}"
)
def
read_item
(
request
,
item_id
:
int
):
return
{
"item_id"
:
item_id
}
Path params with slashes
Django's
path
converter allows you to handle path-like parameters:
@api
.
get
(
'/dir/{path:value}'
)
def
someview
(
request
,
value
:
str
):
return
value
you can query this operation with
/dir/some/path/with-slashes
and your
value
will be equal to
some/path/with-slashes
Multiple parameters
You can pass as many variables as you want into
path
, just remember to have unique names and don't forget to use the same names in the function arguments.
@api
.
get
(
"/events/
{year}
/
{month}
/
{day}
"
)
def
events
(
request
,
year
:
int
,
month
:
int
,
day
:
int
):
return
{
"date"
:
[
year
,
month
,
day
]}
Using Schema
You can also use Schema to encapsulate path parameters that depend on each other (and validate them as a group):
import
datetime
from
ninja
import
Schema
,
Path
class
PathDate
(
Schema
):
year
:
int
month
:
int
day
:
int
def
value
(
self
):
return
datetime
.
date
(
self
.
year
,
self
.
month
,
self
.
day
)
@api
.
get
(
"/events/
{year}
/
{month}
/
{day}
"
)
def
events
(
request
,
date
:
Path
[
PathDate
]):
return
{
"date"
:
date
.
value
()}
Note
Notice that here we used a
Path
source hint to let
Django Ninja
know that this schema will be applied to path parameters.
Documentation
Now, when you open your browser at
http://localhost:8000/api/docs
, you will see the automatic, interactive, API documentation.
Previous
HTTP Methods
Next
Query parameters
Made with
Material for MkDocs
----------------------------------------
Title: Query parameters
Content:
Query parameters - Django Ninja
Skip to content
Django Ninja
Query parameters
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Query parameters
Table of contents
Defaults
Required and optional parameters
GET parameters type conversion
Using Schema
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Defaults
Required and optional parameters
GET parameters type conversion
Using Schema
Query parameters
When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as "query" parameters.
weapons
=
[
"Ninjato"
,
"Shuriken"
,
"Katana"
,
"Kama"
,
"Kunai"
,
"Naginata"
,
"Yari"
]
@api
.
get
(
"/weapons"
)
def
list_weapons
(
request
,
limit
:
int
=
10
,
offset
:
int
=
0
):
return
weapons
[
offset
:
offset
+
limit
]
To query this operation, you use a URL like:
http://localhost:8000/api/weapons?offset=0&limit=10
By default, all GET parameters are strings, and when you annotate your function arguments with types, they are converted to that type and validated against it.
The same benefits that apply to path parameters also apply to query parameters:
Editor support (obviously)
Data "parsing"
Data validation
Automatic documentation
Note
if you do not annotate your arguments, they will be treated as
str
types
@api
.
get
(
"/weapons"
)
def
list_weapons
(
request
,
limit
,
offset
):
# type(limit) == str
# type(offset) == str
Defaults
As query parameters are not a fixed part of a path, they are optional and can have default values:
@api
.
get
(
"/weapons"
)
def
list_weapons
(
request
,
limit
:
int
=
10
,
offset
:
int
=
0
):
return
weapons
[
offset
:
offset
+
limit
]
In the example above we set default values of
offset=0
and
limit=10
.
So, going to the URL:
http://localhost:8000/api/weapons
would be the same as going to:
http://localhost:8000/api/weapons?offset=0&limit=10
If you go to, for example:
http://localhost:8000/api/weapons?offset=20
the parameter values in your function will be:
offset=20
(because you set it in the URL)
limit=10
(because that was the default value)
Required and optional parameters
You can declare required or optional GET parameters in the same way as declaring Python function arguments:
weapons
=
[
"Ninjato"
,
"Shuriken"
,
"Katana"
,
"Kama"
,
"Kunai"
,
"Naginata"
,
"Yari"
]
@api
.
get
(
"/weapons/search"
)
def
search_weapons
(
request
,
q
:
str
,
offset
:
int
=
0
):
results
=
[
w
for
w
in
weapons
if
q
in
w
.
lower
()]
return
results
[
offset
:
offset
+
10
]
In this case,
Django Ninja
will always validate that you pass the
q
param in the GET, and the
offset
param is an optional integer.
GET parameters type conversion
Let's declare multiple type arguments:
from
datetime
import
date
@api
.
get
(
"/example"
)
def
example
(
request
,
s
:
str
=
None
,
b
:
bool
=
None
,
d
:
date
=
None
,
i
:
int
=
None
):
return
[
s
,
b
,
d
,
i
]
The
str
type is passed as is.
For the
bool
type, all the following:
http://localhost:8000/api/example?b=1
http://localhost:8000/api/example?b=True
http://localhost:8000/api/example?b=true
http://localhost:8000/api/example?b=on
http://localhost:8000/api/example?b=yes
or any other case variation (uppercase, first letter in uppercase, etc.), your function will see
the parameter
b
with a
bool
value of
True
, otherwise as
False
.
Date can be both date string and integer (unix timestamp):
http://localhost:8000/api/example?d=
1577836800
# same as 2020-01-01
http://localhost:8000/api/example?d=
2020-01-01
Using Schema
You can also use Schema to encapsulate GET parameters:
import
datetime
from
typing
import
List
from
pydantic
import
Field
from
ninja
import
Query
,
Schema
class
Filters
(
Schema
):
limit
:
int
=
100
offset
:
int
=
None
query
:
str
=
None
category__in
:
List
[
str
]
=
Field
(
None
,
alias
=
"categories"
)
@api
.
get
(
"/filter"
)
def
events
(
request
,
filters
:
Query
[
Filters
]):
return
{
"filters"
:
filters
.
dict
()}
For more complex filtering scenarios please refer to
filtering
.
Previous
Path parameters
Next
Request Body
Made with
Material for MkDocs
----------------------------------------
Title: Request Body
Content:
Request Body - Django Ninja
Skip to content
Django Ninja
Request Body
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Request Body
Table of contents
Import Schema
Create your data model
Declare it as a parameter
Results
Automatic docs
Editor support
Request body + path parameters
Request body + path + query parameters
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Import Schema
Create your data model
Declare it as a parameter
Results
Automatic docs
Editor support
Request body + path parameters
Request body + path + query parameters
Request Body
Request bodies are typically used with “create” and “update” operations (POST, PUT, PATCH).
For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created.
To declare a
request body
, you need to use
Django Ninja
Schema
.
Info
Under the hood
Django Ninja
uses
Pydantic
models with all their power and benefits.
The alias
Schema
was chosen to avoid confusion in code when using Django models, as Pydantic's model class is called Model by default, and conflicts with Django's Model class.
Import Schema
First, you need to import
Schema
from
ninja
:
from
typing
import
Optional
from
ninja
import
Schema
class
Item
(
Schema
):
name
:
str
description
:
Optional
[
str
]
=
None
price
:
float
quantity
:
int
@api
.
post
(
"/items"
)
def
create
(
request
,
item
:
Item
):
return
item
Create your data model
Then you declare your data model as a class that inherits from
Schema
.
Use standard Python types for all the attributes:
from
typing
import
Optional
from
ninja
import
Schema
class
Item
(
Schema
):
name
:
str
description
:
Optional
[
str
]
=
None
price
:
float
quantity
:
int
@api
.
post
(
"/items"
)
def
create
(
request
,
item
:
Item
):
return
item
Note: if you use
None
as the default value for an attribute, it will become optional in the request body.
For example, this model above declares a JSON "
object
" (or Python
dict
) like:
{
"name"
:
"Katana"
,
"description"
:
"An optional description"
,
"price"
:
299.00
,
"quantity"
:
10
}
...as
description
is optional (with a default value of
None
), this JSON "
object
" would also be valid:
{
"name"
:
"Katana"
,
"price"
:
299.00
,
"quantity"
:
10
}
Declare it as a parameter
To add it to your
path operation
, declare it the same way you declared the path and query parameters:
from
typing
import
Optional
from
ninja
import
Schema
class
Item
(
Schema
):
name
:
str
description
:
Optional
[
str
]
=
None
price
:
float
quantity
:
int
@api
.
post
(
"/items"
)
def
create
(
request
,
item
:
Item
):
return
item
... and declare its type as the model you created,
Item
.
Results
With just that Python type declaration,
Django Ninja
will:
Read the body of the request as JSON.
Convert the corresponding types (if needed).
Validate the data.
If the data is invalid, it will return a nice and meaningful error, indicating exactly where and what the incorrect data was.
Give you the received data in the parameter
item
.
Because you declared it in the function to be of type
Item
, you will also have all the editor support
  (completion, etc.) for all the attributes and their types.
Generate
JSON Schema
definitions for
  your models, and you can also use them anywhere else you like if it makes sense for your project.
Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation
UI's
.
Automatic docs
The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs:
... and they will be also used in the API docs inside each
path operation
that needs them:
Editor support
In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a
dict
instead of a Schema object):
The previous screenshots were taken with
Visual Studio Code
.
You would get the same editor support with
PyCharm
and most of the other Python editors.
Request body + path parameters
You can declare path parameters
and
body requests at the same time.
Django Ninja
will recognize that the function parameters that match path parameters should be
taken from the path
, and that function parameters that are declared with
Schema
should be
taken from the request body
.
from
ninja
import
Schema
class
Item
(
Schema
):
name
:
str
description
:
str
=
None
price
:
float
quantity
:
int
@api
.
put
(
"/items/
{item_id}
"
)
def
update
(
request
,
item_id
:
int
,
item
:
Item
):
return
{
"item_id"
:
item_id
,
"item"
:
item
.
dict
()}
Request body + path + query parameters
You can also declare
body
,
path
and
query
parameters, all at the same time.
Django Ninja
will recognize each of them and take the data from the correct place.
from
ninja
import
Schema
class
Item
(
Schema
):
name
:
str
description
:
str
=
None
price
:
float
quantity
:
int
@api
.
post
(
"/items/
{item_id}
"
)
def
update
(
request
,
item_id
:
int
,
item
:
Item
,
q
:
str
):
return
{
"item_id"
:
item_id
,
"item"
:
item
.
dict
(),
"q"
:
q
}
The function parameters will be recognized as follows:
If the parameter is also declared in the
path
, it will be used as a path parameter.
If the parameter is of a
singular type
(like
int
,
float
,
str
,
bool
, etc.), it will be interpreted as a
query
parameter.
If the parameter is declared to be of the type of
Schema
(or Pydantic
BaseModel
), it will be interpreted as a request
body
.
Previous
Query parameters
Next
Form data
Made with
Material for MkDocs
----------------------------------------
Title: Form data
Content:
Form data - Django Ninja
Skip to content
Django Ninja
Form data
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
Form data
Table of contents
Form Data as params
Using a Schema
Request form + path + query parameters
Mapping Empty Form Field to Default
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Form Data as params
Using a Schema
Request form + path + query parameters
Mapping Empty Form Field to Default
Form data
Django Ninja
also allows you to parse and validate
request.POST
data
(aka
application/x-www-form-urlencoded
or
multipart/form-data
).
Form Data as params
from
ninja
import
NinjaAPI
,
Form
@api
.
post
(
"/login"
)
def
login
(
request
,
username
:
Form
[
str
],
password
:
Form
[
str
]):
return
{
'username'
:
username
,
'password'
:
'*****'
}
Note the following:
1) You need to import the
Form
class from
ninja
from
ninja
import
Form
2) Use
Form
as default value for your parameter:
username
:
Form
[
str
]
Using a Schema
In a similar manner to
Body
, you can use
a Schema to organize your parameters.
from
ninja
import
Form
,
Schema
class
Item
(
Schema
):
name
:
str
description
:
str
=
None
price
:
float
quantity
:
int
@api
.
post
(
"/items"
)
def
create
(
request
,
item
:
Form
[
Item
]):
return
item
Request form + path + query parameters
In a similar manner to
Body
, you can use
Form data in combination with other parameter sources.
You can declare query
and
path
and
form field,
and
etc... parameters at the same time.
Django Ninja
will recognize that the function parameters that match path
parameters should be
taken from the path
, and that function parameters that
are declared with
Form(...)
should be
taken from the request form fields
, etc.
from
ninja
import
Form
,
Schema
class
Item
(
Schema
):
name
:
str
description
:
str
=
None
price
:
float
quantity
:
int
@api
.
post
(
"/items/
{item_id}
"
)
def
update
(
request
,
item_id
:
int
,
q
:
str
,
item
:
Form
[
Item
]):
return
{
"item_id"
:
item_id
,
"item"
:
item
.
dict
(),
"q"
:
q
}
Mapping Empty Form Field to Default
Form fields that are optional, are often sent with an empty value. This value is
interpreted as an empty string, and thus may fail validation for fields such as
int
or
bool
.
This can be fixed, as described in the Pydantic docs, by using
Generic Classes as Types
.
from
ninja
import
Form
,
Schema
from
typing
import
Annotated
,
TypeVar
from
pydantic
import
WrapValidator
from
pydantic_core
import
PydanticUseDefault
def
_empty_str_to_default
(
v
,
handler
,
info
):
if
isinstance
(
v
,
str
)
and
v
==
''
:
raise
PydanticUseDefault
return
handler
(
v
)
T
=
TypeVar
(
'T'
)
EmptyStrToDefault
=
Annotated
[
T
,
WrapValidator
(
_empty_str_to_default
)]
class
Item
(
Schema
):
name
:
str
description
:
str
=
None
price
:
EmptyStrToDefault
[
float
]
=
0.0
quantity
:
EmptyStrToDefault
[
int
]
=
0
in_stock
:
EmptyStrToDefault
[
bool
]
=
True
@api
.
post
(
"/items-blank-default"
)
def
update
(
request
,
item
:
Form
[
Item
]):
return
item
.
dict
()
Previous
Request Body
Next
File uploads
Made with
Material for MkDocs
----------------------------------------
Title: File uploads
Content:
File uploads - Django Ninja
Skip to content
Django Ninja
File uploads
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
File uploads
Table of contents
Uploading array of files
Uploading files with extra fields
List of files with extra info
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Uploading array of files
Uploading files with extra fields
List of files with extra info
File uploads
Handling files are no different from other parameters.
from
ninja
import
NinjaAPI
,
File
from
ninja.files
import
UploadedFile
@api
.
post
(
"/upload"
)
def
upload
(
request
,
file
:
UploadedFile
=
File
(
...
)):
data
=
file
.
read
()
return
{
'name'
:
file
.
name
,
'len'
:
len
(
data
)}
UploadedFile
is an alias to
Django's UploadFile
and has all the methods and attributes to access the uploaded file:
read()
multiple_chunks(chunk_size=None)
chunks(chunk_size=None)
name
size
content_type
content_type_extra
charset
etc.
Uploading array of files
To
upload several files
at the same time, just declare a
List
of
UploadedFile
:
from
typing
import
List
from
ninja
import
NinjaAPI
,
File
from
ninja.files
import
UploadedFile
@api
.
post
(
"/upload-many"
)
def
upload_many
(
request
,
files
:
List
[
UploadedFile
]
=
File
(
...
)):
return
[
f
.
name
for
f
in
files
]
Uploading files with extra fields
Note: The HTTP protocol does not allow you to send files in
application/json
format by default (unless you encode it somehow to JSON on client side)
To send files along with some extra attributes, you need to send bodies with
multipart/form-data
encoding. You can do it by simply marking fields with
Form
:
from
ninja
import
NinjaAPI
,
Schema
,
UploadedFile
,
Form
,
File
from
datetime
import
date
api
=
NinjaAPI
()
class
UserDetails
(
Schema
):
first_name
:
str
last_name
:
str
birthdate
:
date
@api
.
post
(
'/users'
)
def
create_user
(
request
,
details
:
Form
[
UserDetails
],
file
:
File
[
UploadedFile
]):
return
[
details
.
dict
(),
file
.
name
]
Note: in this case all fields should be send as form fields
You can as well send payload in single field as JSON - just remove the Form mark from:
@api
.
post
(
'/users'
)
def
create_user
(
request
,
details
:
UserDetails
,
file
:
File
[
UploadedFile
]):
return
[
details
.
dict
(),
file
.
name
]
this will expect from the client side to send data as `multipart/form-data with 2 fields:
details: JSON as string
file: file
List of files with extra info
@api
.
post
(
'/users'
)
def
create_user
(
request
,
details
:
Form
[
UserDetails
],
files
:
File
[
list
[
UploadedFile
]]):
return
[
details
.
dict
(),
[
f
.
name
for
f
in
files
]]
Previous
Form data
Next
Request parsers
Made with
Material for MkDocs
----------------------------------------
Title: Request parsers
Content:
Request parsers - Django Ninja
Skip to content
Django Ninja
Request parsers
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Request parsers
Table of contents
Example YAML Parser
Example ORJSON Parser
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Example YAML Parser
Example ORJSON Parser
Request parsers
In most cases, the default content type for REST API's is JSON, but in case you need to work with
other content types (like YAML, XML, CSV) or use faster JSON parsers,
Django Ninja
provides a
parser
configuration.
api
=
NinjaAPI
(
parser
=
MyYamlParser
())
To create your own parser, you need to extend the
ninja.parser.Parser
class, and override the
parse_body
method.
Example YAML Parser
Let's create our custom YAML parser:
import
yaml
from
typing
import
List
from
ninja
import
NinjaAPI
from
ninja.parser
import
Parser
class
MyYamlParser
(
Parser
):
def
parse_body
(
self
,
request
):
return
yaml
.
safe_load
(
request
.
body
)
api
=
NinjaAPI
(
parser
=
MyYamlParser
())
class
Payload
(
Schema
):
ints
:
List
[
int
]
string
:
str
f
:
float
@api
.
post
(
'/yaml'
)
def
operation
(
request
,
payload
:
Payload
):
return
payload
.
dict
()
If you now send YAML like this as the request body:
ints
:
-
0
-
1
string
:
hello
f
:
3.14
it will be correctly parsed, and you should have JSON output like this:
{
"ints"
:
[
0
,
1
],
"string"
:
"hello"
,
"f"
:
3.14
}
Example ORJSON Parser
orjson
is a fast, accurate JSON library for Python. It benchmarks as the fastest Python library for JSON and is more accurate than the standard
json
library or other third-party libraries.
pip install orjson
Parser code:
import
orjson
from
ninja
import
NinjaAPI
from
ninja.parser
import
Parser
class
ORJSONParser
(
Parser
):
def
parse_body
(
self
,
request
):
return
orjson
.
loads
(
request
.
body
)
api
=
NinjaAPI
(
parser
=
ORJSONParser
())
Previous
File uploads
Next
Filtering
Made with
Material for MkDocs
----------------------------------------
Title: Filtering
Content:
Filtering - Django Ninja
Skip to content
Django Ninja
Filtering
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Filtering
Table of contents
Customizing Fields
Combining expressions
Filtering by Nones
Custom expressions
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Customizing Fields
Combining expressions
Filtering by Nones
Custom expressions
Filtering
If you want to allow the user to filter your querysets by a number of different attributes, it makes sense
to encapsulate your filters into a
FilterSchema
class.
FilterSchema
is a regular
Schema
, so it's using all the
necessary features of Pydantic, but it also adds some bells and whistles that ease the translation of the user-facing filtering
parameters into database queries.
Start off with defining a subclass of
FilterSchema
:
from
ninja
import
FilterSchema
,
Field
from
typing
import
Optional
class
BookFilterSchema
(
FilterSchema
):
name
:
Optional
[
str
]
=
None
author
:
Optional
[
str
]
=
None
created_after
:
Optional
[
datetime
]
=
None
Next, use this schema in conjunction with
Query
in your API handler:
@api
.
get
(
"/books"
)
def
list_books
(
request
,
filters
:
BookFilterSchema
=
Query
(
...
)):
books
=
Book
.
objects
.
all
()
books
=
filters
.
filter
(
books
)
return
books
Just like described in
defining query params using schema
, Django Ninja converts the fields
defined in
BookFilterSchema
into query parameters.
You can use a shorthand one-liner
.filter()
to apply those filters to your queryset:
@api
.
get
(
"/books"
)
def
list_books
(
request
,
filters
:
BookFilterSchema
=
Query
(
...
)):
books
=
Book
.
objects
.
all
()
books
=
filters
.
filter
(
books
)
return
books
Under the hood,
FilterSchema
converts its fields into
Q expressions
which it then combines and uses to filter your queryset.
Alternatively to using the
.filter
method, you can get the prepared
Q
-expression and perform the filtering yourself.
That can be useful, when you have some additional queryset filtering on top of what you expose to the user through the API:
@api
.
get
(
"/books"
)
def
list_books
(
request
,
filters
:
BookFilterSchema
=
Query
(
...
)):
# Never serve books from inactive publishers and authors
q
=
Q
(
author__is_active
=
True
)
|
Q
(
publisher__is_active
=
True
)
# But allow filtering the rest of the books
q
&=
filters
.
get_filter_expression
()
return
Book
.
objects
.
filter
(
q
)
By default, the filters will behave the following way:
None
values will be ignored and not filtered against;
Every non-
None
field will be converted into a
Q
-expression based on the
Field
definition of each field;
All
Q
-expressions will be merged into one using
AND
logical operator;
The resulting
Q
-expression is used to filter the queryset and return you a queryset with a
.filter
clause applied.
Customizing Fields
By default,
FilterSet
will use the field names to generate Q expressions:
class
BookFilterSchema
(
FilterSchema
):
name
:
Optional
[
str
]
=
None
The
name
field will be converted into
Q(name=...)
expression.
When your database lookups are more complicated than that, you can explicitly specify them in the field definition using a
"q"
kwarg:
class
BookFilterSchema
(
FilterSchema
):
name
:
Optional
[
str
]
=
Field
(
None
,
q
=
'name__icontains'
)
You can even specify multiple lookup keyword argument names as a list:
class
BookFilterSchema
(
FilterSchema
):
search
:
Optional
[
str
]
=
Field
(
None
,
q
=
[
'name__icontains'
,
'author__name__icontains'
,
'publisher__name__icontains'
])
By default, field-level expressions are combined using
"OR"
connector, so with the above setup, a query parameter
?search=foobar
will search for books that have "foobar" in either of their name, author or publisher.
Combining expressions
By default,
Field-level expressions are joined together using
OR
operator.
The fields themselves are joined together using
AND
operator.
So, with the following
FilterSchema
...
class
BookFilterSchema
(
FilterSchema
):
search
:
Optional
[
str
]
=
Field
(
None
,
q
=
[
'name__icontains'
,
'author__name__icontains'
])
popular
:
Optional
[
bool
]
=
None
...and the following query parameters from the user
http://localhost:8000/api/books?search=harry&popular=true
the
FilterSchema
instance will look for popular books that have
harry
in the book's
or
author's name.
You can customize this behavior using an
expression_connector
argument in field-level and class-level definition:
class
BookFilterSchema
(
FilterSchema
):
active
:
Optional
[
bool
]
=
Field
(
None
,
q
=
[
'is_active'
,
'publisher__is_active'
],
expression_connector
=
'AND'
)
name
:
Optional
[
str
]
=
Field
(
None
,
q
=
'name__icontains'
)
class
Config
:
expression_connector
=
'OR'
An expression connector can take the values of
"OR"
,
"AND"
and
"XOR"
, but the latter is only
supported
in Django starting with 4.1.
Now, a request with these query parameters
http://localhost:8000/api/books?name=harry&active=true
...shall search for books that have
harry
in their name
or
are active themselves
and
are published by active publishers.
Filtering by Nones
You can make the
FilterSchema
treat
None
as a valid value that should be filtered against.
This can be done on a field level with a
ignore_none
kwarg:
class
BookFilterSchema
(
FilterSchema
):
name
:
Optional
[
str
]
=
Field
(
None
,
q
=
'name__icontains'
)
tag
:
Optional
[
str
]
=
Field
(
None
,
q
=
'tag'
,
ignore_none
=
False
)
This way when no other value for
"tag"
is provided by the user, the filtering will always include a condition
tag=None
.
You can also specify this settings for all fields at the same time in the Config:
class
BookFilterSchema
(
FilterSchema
):
name
:
Optional
[
str
]
=
Field
(
None
,
q
=
'name__icontains'
)
tag
:
Optional
[
str
]
=
Field
(
None
,
q
=
'tag'
,
ignore_none
=
False
)
class
Config
:
ignore_none
=
False
Custom expressions
Sometimes you might want to have complex filtering scenarios that cannot be handled by individual Field annotations.
For such cases you can implement your field filtering logic as a custom method. Simply define a method called
filter_<fieldname>
which takes a filter value and returns a Q expression:
class
BookFilterSchema
(
FilterSchema
):
tag
:
Optional
[
str
]
=
None
popular
:
Optional
[
bool
]
=
None
def
filter_popular
(
self
,
value
:
bool
)
->
Q
:
return
Q
(
view_count__gt
=
1000
)
|
Q
(
download_count__gt
=
100
)
if
value
else
Q
()
Such field methods take precedence over what is specified in the
Field()
definition of the corresponding fields.
If that is not enough, you can implement your own custom filtering logic for the entire
FilterSet
class in a
custom_expression
method:
class
BookFilterSchema
(
FilterSchema
):
name
:
Optional
[
str
]
=
None
popular
:
Optional
[
bool
]
=
None
def
custom_expression
(
self
)
->
Q
:
q
=
Q
()
if
self
.
name
:
q
&=
Q
(
name__icontains
=
self
.
name
)
if
self
.
popular
:
q
&=
(
Q
(
view_count__gt
=
1000
)
|
Q
(
downloads__gt
=
100
)
|
Q
(
tag
=
'popular'
)
)
return
q
The
custom_expression
method takes precedence over any other definitions described earlier, including
filter_<fieldname>
methods.
Previous
Request parsers
Next
Defining a Schema
Made with
Material for MkDocs
----------------------------------------
Title: Defining a Schema
Content:
Defining a Schema - Django Ninja
Skip to content
Django Ninja
Defining a Schema
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Defining a Schema
Table of contents
Nested objects
Aliases
Resolvers
Accessing extra context
Returning querysets
FileField and ImageField
Multiple Response Schemas
Multiple response codes
Empty responses
Self-referencing schemes
Self-referencing schemes from create_schema()
Serializing Outside of Views
Django HTTP responses
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Nested objects
Aliases
Resolvers
Accessing extra context
Returning querysets
FileField and ImageField
Multiple Response Schemas
Multiple response codes
Empty responses
Self-referencing schemes
Self-referencing schemes from create_schema()
Serializing Outside of Views
Django HTTP responses
Response Schema
Django Ninja
allows you to define the schema of your responses both for validation and documentation purposes.
Imagine you need to create an API operation that creates a user. The
input
parameter would be
username+password
, but
output
of this operation should be
id+username
(
without
the password).
Let's create the input schema:
from
ninja
import
Schema
class
UserIn
(
Schema
):
username
:
str
password
:
str
@api
.
post
(
"/users/"
)
def
create_user
(
request
,
data
:
UserIn
):
user
=
User
(
username
=
data
.
username
)
# User is django auth.User
user
.
set_password
(
data
.
password
)
user
.
save
()
# ... return ?
Now let's define the output schema, and pass it as a
response
argument to the
@api.post
decorator:
from
ninja
import
Schema
class
UserIn
(
Schema
):
username
:
str
password
:
str
class
UserOut
(
Schema
):
id
:
int
username
:
str
@api
.
post
(
"/users/"
,
response
=
UserOut
)
def
create_user
(
request
,
data
:
UserIn
):
user
=
User
(
username
=
data
.
username
)
user
.
set_password
(
data
.
password
)
user
.
save
()
return
user
Django Ninja
will use this
response
schema to:
convert the output data to declared schema
validate the data
add an OpenAPI schema definition
it will be used by the automatic documentation systems
and, most importantly, it
will limit the output data
only to the fields only defined in the schema.
Nested objects
There is also often a need to return responses with some nested/child objects.
Imagine we have a
Task
Django model with a
User
ForeignKey:
from
django.db
import
models
class
Task
(
models
.
Model
):
title
=
models
.
CharField
(
max_length
=
200
)
is_completed
=
models
.
BooleanField
(
default
=
False
)
owner
=
models
.
ForeignKey
(
"auth.User"
,
null
=
True
,
blank
=
True
)
Now let's output all tasks, and for each task, output some fields about the user.
from
typing
import
List
from
ninja
import
Schema
class
UserSchema
(
Schema
):
id
:
int
first_name
:
str
last_name
:
str
class
TaskSchema
(
Schema
):
id
:
int
title
:
str
is_completed
:
bool
owner
:
UserSchema
=
None
# ! None - to mark it as optional
@api
.
get
(
"/tasks"
,
response
=
List
[
TaskSchema
])
def
tasks
(
request
):
queryset
=
Task
.
objects
.
select_related
(
"owner"
)
return
list
(
queryset
)
If you execute this operation, you should get a response like this:
[
{
"id"
:
1
,
"title"
:
"Task 1"
,
"is_completed"
:
false
,
"owner"
:
{
"id"
:
1
,
"first_name"
:
"John"
,
"last_name"
:
"Doe"
,
}
},
{
"id"
:
2
,
"title"
:
"Task 2"
,
"is_completed"
:
false
,
"owner"
:
null
},
]
Aliases
Instead of a nested response, you may want to just flatten the response output.
The Ninja
Schema
object extends Pydantic's
Field(..., alias="")
format to
work with dotted responses.
Using the models from above, let's make a schema that just includes the task
owner's first name inline, and also uses
completed
rather than
is_completed
:
from
ninja
import
Field
,
Schema
class
TaskSchema
(
Schema
):
id
:
int
title
:
str
# The first Field param is the default, use ... for required fields.
completed
:
bool
=
Field
(
...
,
alias
=
"is_completed"
)
owner_first_name
:
str
=
Field
(
None
,
alias
=
"owner.first_name"
)
Aliases also support django template syntax variables access:
class
TaskSchema
(
Schema
):
last_message
:
str
=
Field
(
None
,
alias
=
"message_set.0.text"
)
class
TaskSchema
(
Schema
):
type
:
str
=
Field
(
None
)
type_display
:
str
=
Field
(
None
,
alias
=
"get_type_display"
)
# callable will be executed
Resolvers
You can also create calculated fields via resolve methods based on the field
name.
The method must accept a single argument, which will be the object the schema
is resolving against.
When creating a resolver as a standard method,
self
gives you access to other
validated and formatted attributes in the schema.
class
TaskSchema
(
Schema
):
id
:
int
title
:
str
is_completed
:
bool
owner
:
Optional
[
str
]
=
None
lower_title
:
str
@staticmethod
def
resolve_owner
(
obj
):
if
not
obj
.
owner
:
return
return
f
"
{
obj
.
owner
.
first_name
}
{
obj
.
owner
.
last_name
}
"
def
resolve_lower_title
(
self
,
obj
):
return
self
.
title
.
lower
()
Accessing extra context
Pydantic v2 allows you to process an extra context that is passed to the serializer. In the following example you can have resolver that gets request object from passed
context
argument:
class
Data
(
Schema
):
a
:
int
path
:
str
=
""
@staticmethod
def
resolve_path
(
obj
,
context
):
request
=
context
[
"request"
]
return
request
.
path
if you use this schema for incoming requests - the
request
object will be automatically passed to context.
You can as well pass your own context:
data
=
Data
.
model_validate
({
'some'
:
1
},
context
=
{
'request'
:
MyRequest
()})
Returning querysets
In the previous example we specifically converted a queryset into a list (and executed the SQL query during evaluation).
You can avoid that and return a queryset as a result, and it will be automatically evaluated to List:
@api
.
get
(
"/tasks"
,
response
=
List
[
TaskSchema
])
def
tasks
(
request
):
return
Task
.
objects
.
all
()
Warning
If your operation is async, this example will not work because the ORM query needs to be called safely.
@api
.
get
(
"/tasks"
,
response
=
List
[
TaskSchema
])
async
def
tasks
(
request
):
return
Task
.
objects
.
all
()
See the
async support
guide for more information.
FileField and ImageField
Django Ninja
by default converts files and images (declared with
FileField
or
ImageField
) to
string
URL's.
An example:
class
Picture
(
models
.
Model
):
title
=
models
.
CharField
(
max_length
=
100
)
image
=
models
.
ImageField
(
upload_to
=
'images'
)
If you need to output to response image field, declare a schema for it as follows:
class
PictureSchema
(
Schema
):
title
:
str
image
:
str
Once you output this to a response, the URL will be automatically generated for each object:
{
"title"
:
"Zebra"
,
"image"
:
"/static/images/zebra.jpg"
}
Multiple Response Schemas
Sometimes you need to define more than response schemas.
In case of authentication, for example, you can return:
200
successful -> token
401
-> Unauthorized
402
-> Payment required
etc..
In fact, the
OpenAPI specification
allows you to pass multiple response schemas.
You can pass to a
response
argument a dictionary where:
key is a response code
value is a schema for that code
Also, when you return the result - you have to also pass a status code to tell
Django Ninja
which schema should be used for validation and serialization.
An example:
class
Token
(
Schema
):
token
:
str
expires
:
date
class
Message
(
Schema
):
message
:
str
@api
.
post
(
'/login'
,
response
=
{
200
:
Token
,
401
:
Message
,
402
:
Message
})
def
login
(
request
,
payload
:
Auth
):
if
auth_not_valid
:
return
401
,
{
'message'
:
'Unauthorized'
}
if
negative_balance
:
return
402
,
{
'message'
:
'Insufficient balance amount. Please proceed to a payment page.'
}
return
200
,
{
'token'
:
xxx
,
...
}
Multiple response codes
In the previous example you saw that we basically repeated the
Message
schema twice:
...401: Message, 402: Message}
To avoid this duplication you can use multiple response codes for a schema:
...
from
ninja.responses
import
codes_4xx
@api
.
post
(
'/login'
,
response
=
{
200
:
Token
,
codes_4xx
:
Message
})
def
login
(
request
,
payload
:
Auth
):
if
auth_not_valid
:
return
401
,
{
'message'
:
'Unauthorized'
}
if
negative_balance
:
return
402
,
{
'message'
:
'Insufficient balance amount. Please proceed to a payment page.'
}
return
200
,
{
'token'
:
xxx
,
...
}
Django Ninja
comes with the following HTTP codes:
from
ninja.responses
import
codes_1xx
from
ninja.responses
import
codes_2xx
from
ninja.responses
import
codes_3xx
from
ninja.responses
import
codes_4xx
from
ninja.responses
import
codes_5xx
You can also create your own range using a
frozenset
:
my_codes
=
frozenset
({
416
,
418
,
425
,
429
,
451
})
...
@api
.
post
(
'/login'
,
response
=
{
200
:
Token
,
my_codes
:
Message
})
...
Empty responses
Some responses, such as
204 No Content
, have no body. To indicate the response body is empty mark
response
argument with
None
instead of Schema:
@api
.
post
(
"/no_content"
,
response
=
{
204
:
None
})
def
no_content
(
request
):
return
204
,
None
Self-referencing schemes
Sometimes you need to create a schema that has reference to itself, or tree-structure objects.
To do that you need:
set a type of your schema in quotes
use
update_forward_refs
method to apply self referencing types
class
Organization
(
Schema
):
title
:
str
part_of
:
'Organization'
=
None
#!! note the type in quotes here !!
Organization
.
update_forward_refs
()
# !!! this is important
@api
.
get
(
'/organizations'
,
response
=
List
[
Organization
])
def
list_organizations
(
request
):
...
Self-referencing schemes from
create_schema()
To be able to use the method
update_forward_refs()
from a schema generated via
create_schema()
,
the "name" of the class needs to be in our namespace.  In this case it is very important to pass
the
name
parameter to
create_schema()
UserSchema
=
create_schema
(
User
,
name
=
'UserSchema'
,
# !!! this is important for update_forward_refs()
fields
=
[
'id'
,
'username'
]
custom_fields
=
[
(
'manager'
,
'UserSchema'
,
None
),
]
)
UserSchema
.
update_forward_refs
()
Serializing Outside of Views
Serialization of your objects can be done directly in code through the use of
the
.from_orm()
method on the schema object.
Consider the following model:
class
Person
(
models
.
Model
):
name
=
models
.
CharField
(
max_length
=
50
)
Which can be accessed using this schema:
class
PersonSchema
(
Schema
):
name
:
str
Direct serialization can be performed using the
.from_orm()
method on the
schema. Once you have an instance of the schema object, the
.dict()
and
.json()
methods allow you to get at both dictionary output and string JSON
versions.
>>>
person
=
Person
.
objects
.
get
(
id
=
1
)
>>>
data
=
PersonSchema
.
from_orm
(
person
)
>>>
data
PersonSchema
(
id
=
1
,
name
=
'Mr. Smith'
)
>>>
data
.
dict
()
{
'id'
:
1
,
'name'
:
'Mr. Smith'
}
>>>
data
.
json
()
'{"id":1, "name":"Mr. Smith"}'
Multiple Items: or a queryset (or list)
>>>
persons
=
Person
.
objects
.
all
()
>>>
data
=
[
PersonSchema
.
from_orm
(
i
)
.
dict
()
for
i
in
persons
]
[{
'id'
:
1
,
'name'
:
'Mr. Smith'
},{
'id'
:
2
,
'name'
:
'Mrs. Smith'
}
...
]
Django HTTP responses
It is also possible to return regular django http responses:
from
django.http
import
HttpResponse
from
django.shortcuts
import
redirect
@api
.
get
(
"/http"
)
def
result_django
(
request
):
return
HttpResponse
(
'some data'
)
# !!!!
@api
.
get
(
"/something"
)
def
some_redirect
(
request
):
return
redirect
(
"/some-path"
)
# !!!!
Previous
Filtering
Next
Altering the Response
Made with
Material for MkDocs
----------------------------------------
Title: Altering the Response
Content:
Altering the Response - Django Ninja
Skip to content
Django Ninja
Altering the Response
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Altering the Response
Table of contents
Temporal response object
Changing the base response object
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Temporal response object
Changing the base response object
Altering the Response
Sometimes you'll want to change the response just before it gets served, for example, to add a header or alter a cookie.
To do this, simply declare a function parameter with a type of
HttpResponse
:
from
django.http
import
HttpRequest
,
HttpResponse
@api
.
get
(
"/cookie/"
)
def
feed_cookiemonster
(
request
:
HttpRequest
,
response
:
HttpResponse
):
# Set a cookie.
response
.
set_cookie
(
"cookie"
,
"delicious"
)
# Set a header.
response
[
"X-Cookiemonster"
]
=
"blue"
return
{
"cookiemonster_happy"
:
True
}
Temporal response object
This response object is used for the base of all responses built by Django Ninja, including error responses. This object is
not
used if a Django
HttpResponse
object is returned directly by an operation.
Obviously this response object won't contain the content yet, but it does have the
content_type
set (but you probably don't want to be changing it).
The
status_code
will get overridden depending on the return value (200 by default, or the status code if a two-part tuple is returned).
Changing the base response object
You can alter this temporal response object by overriding the
NinjaAPI.create_temporal_response
method.
def
create_temporal_response
(
self
,
request
:
HttpRequest
)
->
HttpResponse
:
response
=
super
()
.
create_temporal_response
(
request
)
# Do your magic here...
return
response
Previous
Defining a Schema
Next
Generating a Schema from Django models
Made with
Material for MkDocs
----------------------------------------
Title: Generating a Schema from Django models
Content:
Generating a Schema from Django models - Django Ninja
Skip to content
Django Ninja
Generating a Schema from Django models
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema from Django models
Table of contents
ModelSchema
Using ALL model fields
Excluding model fields
Overriding fields
Making fields optional
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
ModelSchema
Using ALL model fields
Excluding model fields
Overriding fields
Making fields optional
Schemas from Django models
Schemas are very useful to define your validation rules and responses, but sometimes you need to reflect your database models into schemas and keep changes in sync.
ModelSchema
ModelSchema
is a special base class that can automatically generate schemas from your models.
All you need is to set
model
and
fields
attributes on your schema
Meta
:
from
django.contrib.auth.models
import
User
from
ninja
import
ModelSchema
class
UserSchema
(
ModelSchema
):
class
Meta
:
model
=
User
fields
=
[
'id'
,
'username'
,
'first_name'
,
'last_name'
]
# Will create schema like this:
#
# class UserSchema(Schema):
#     id: int
#     username: str
#     first_name: str
#     last_name: str
Using ALL model fields
To use all fields from a model - you can pass
__all__
to
fields
:
class
UserSchema
(
ModelSchema
):
class
Meta
:
model
=
User
fields
=
"__all__"
Warning
Using
all
is not recommended.
This can lead to accidental unwanted data exposure (like hashed password, in the above example).
General advice - use
fields
to explicitly define list of fields that you want to be visible in API.
Excluding model fields
To use all fields
except
a few, you can use
exclude
configuration:
class
UserSchema
(
ModelSchema
):
class
Meta
:
model
=
User
exclude
=
[
'password'
,
'last_login'
,
'user_permissions'
]
# Will create schema like this:
#
# class UserSchema(Schema):
#     id: int
#     username: str
#     first_name: str
#     last_name: str
#     email: str
#     is_superuser: bool
#     ... and the rest
Overriding fields
To change default annotation for some field, or to add a new field, just use annotated attributes as usual.
class
GroupSchema
(
ModelSchema
):
class
Meta
:
model
=
Group
fields
=
[
'id'
,
'name'
]
class
UserSchema
(
ModelSchema
):
groups
:
List
[
GroupSchema
]
=
[]
class
Meta
:
model
=
User
fields
=
[
'id'
,
'username'
,
'first_name'
,
'last_name'
]
Making fields optional
Pretty often for PATCH API operations you need to make all fields of your schema optional. To do that you can use config fields_optional
class
PatchGroupSchema
(
ModelSchema
):
class
Meta
:
model
=
Group
fields
=
[
'id'
,
'name'
,
'description'
]
# Note: all these fields are required on model level
fields_optional
=
'__all__'
also you can define just a few optional fields instead of all:
fields_optional
=
[
'description'
]
Previous
Altering the Response
Next
Generating a Schema dynamically
Made with
Material for MkDocs
----------------------------------------
Title: Generating a Schema dynamically
Content:
Generating a Schema dynamically - Django Ninja
Skip to content
Django Ninja
Generating a Schema dynamically
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Generating a Schema dynamically
Table of contents
create_schema
Using fields
Using exclude
Using depth
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
create_schema
Using fields
Using exclude
Using depth
Using create_schema
Under the hood,
ModelSchema
uses the
create_schema
function.
This is a more advanced (and less safe) method - please use it carefully.
create_schema
Django Ninja
comes with a helper function
create_schema
:
def
create_schema
(
model
,
# django model
name
=
""
,
# name for the generated class, if empty model names is used
depth
=
0
,
# if > 0 schema will also be created for the nested ForeignKeys and Many2Many (with the provided depth of lookup)
fields
:
list
[
str
]
=
None
,
# if passed - ONLY these fields will added to schema
exclude
:
list
[
str
]
=
None
,
# if passed - these fields will be excluded from schema
optional_fields
:
list
[
str
]
|
str
=
None
,
# if passed - these fields will not be required on schema (use '__all__' to mark ALL fields required)
custom_fields
:
list
[
tuple
(
str
,
Any
,
Any
)]
=
None
,
# if passed - this will override default field types (or add new fields)
)
Take this example:
from
django.contrib.auth.models
import
User
from
ninja.orm
import
create_schema
UserSchema
=
create_schema
(
User
)
# Will create schema like this:
#
# class UserSchema(Schema):
#     id: int
#     username: str
#     first_name: str
#     last_name: str
#     password: str
#     last_login: datetime
#     is_superuser: bool
#     email: str
#     ... and the rest
Warning
By default
create_schema
builds a schema with ALL model fields.
This can lead to accidental unwanted data exposure (like hashed password, in the above example).
Always
use
fields
or
exclude
arguments to explicitly define list of attributes.
Using
fields
UserSchema
=
create_schema
(
User
,
fields
=
[
'id'
,
'username'
])
# Will create schema like this:
#
# class UserSchema(Schema):
#     id: int
#     username: str
Using
exclude
UserSchema
=
create_schema
(
User
,
exclude
=
[
'password'
,
'last_login'
,
'is_superuser'
,
'is_staff'
,
'groups'
,
'user_permissions'
]
)
# Will create schema without excluded fields:
#
# class UserSchema(Schema):
#    id: int
#    username: str
#    first_name: str
#    last_name: str
#    email: str
#    is_active: bool
#    date_joined: datetime
Using
depth
The
depth
argument allows you to introspect the Django model into the Related fields(ForeignKey, OneToOne, ManyToMany).
UserSchema
=
create_schema
(
User
,
depth
=
1
,
fields
=
[
'username'
,
'groups'
])
# Will create the following schema:
#
# class UserSchema(Schema):
#    username: str
#    groups: List[Group]
Note here that groups became a
List[Group]
- many2many field introspected 1 level deeper and created schema as well for group:
class
Group
(
Schema
):
id
:
int
name
:
str
permissions
:
List
[
int
]
Previous
Generating a Schema from Django models
Next
Overriding Pydantic Config
Made with
Material for MkDocs
----------------------------------------
Title: Overriding Pydantic Config
Content:
Overriding Pydantic Config - Django Ninja
Skip to content
Django Ninja
Overriding Pydantic Config
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Overriding Pydantic Config
Table of contents
Example Camel Case mode
Custom Config from Django Model
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Example Camel Case mode
Custom Config from Django Model
Overriding Pydantic Config
There are many customizations available for a
Django Ninja
Schema
, via the schema's
Pydantic
Config
class
.
Info
Under the hood
Django Ninja
uses
Pydantic Models
with all their power and benefits. The alias
Schema
was chosen to avoid confusion in code
when using Django models, as Pydantic's model class is called Model by default, and conflicts with
Django's Model class.
Example Camel Case mode
One interesting
Config
attribute is
alias_generator
.
Using Pydantic's example in
Django Ninja
can look something like:
from
ninja
import
Schema
def
to_camel
(
string
:
str
)
->
str
:
return
''
.
join
(
word
.
capitalize
()
for
word
in
string
.
split
(
'_'
))
class
CamelModelSchema
(
Schema
):
str_field_name
:
str
float_field_name
:
float
class
Config
(
Schema
.
Config
):
alias_generator
=
to_camel
Note
When overriding the schema's
Config
, it is necessary to inherit from the base
Config
class.
Keep in mind that when you want modify output for field names (like cammel case) - you need to set as well
populate_by_name
and
by_alias
class
UserSchema
(
ModelSchema
):
class
Config
:
model
=
User
model_fields
=
[
"id"
,
"email"
]
alias_generator
=
to_camel
populate_by_name
=
True
# !!!!!! <--------
@api
.
get
(
"/users"
,
response
=
list
[
UserSchema
],
by_alias
=
True
)
# !!!!!! <-------- by_alias
def
get_users
(
request
):
return
User
.
objects
.
all
()
results:
[
{
"Id"
:
1
,
"Email"
:
"tim@apple.com"
},
{
"Id"
:
2
,
"Email"
:
"sarah@smith.com"
}
...
]
Custom Config from Django Model
When using
create_schema
, the resulting
schema can be used to build another class with a custom config like:
from
django.contrib.auth.models
import
User
from
ninja.orm
import
create_schema
BaseUserSchema
=
create_schema
(
User
)
class
UserSchema
(
BaseUserSchema
):
class
Config
(
BaseUserSchema
.
Config
):
...
Previous
Generating a Schema dynamically
Next
Pagination
Made with
Material for MkDocs
----------------------------------------
Title: Pagination
Content:
Pagination - Django Ninja
Skip to content
Django Ninja
Pagination
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Pagination
Table of contents
Built in Pagination Classes
LimitOffsetPagination (default)
PageNumberPagination
Accessing paginator parameters in view function
Creating Custom Pagination Class
Output attribute
Apply pagination to multiple operations at once
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Built in Pagination Classes
LimitOffsetPagination (default)
PageNumberPagination
Accessing paginator parameters in view function
Creating Custom Pagination Class
Output attribute
Apply pagination to multiple operations at once
Pagination
Django Ninja
comes with a pagination support. This allows you to split large result sets into individual pages.
To apply pagination to a function - just apply
paginate
decorator:
from
ninja.pagination
import
paginate
@api
.
get
(
'/users'
,
response
=
List
[
UserSchema
])
@paginate
def
list_users
(
request
):
return
User
.
objects
.
all
()
That's it!
Now you can query users with
limit
and
offset
GET parameters
/api/users?limit=10&offset=0
by default limit is set to
100
(you can change it in your settings.py using
NINJA_PAGINATION_PER_PAGE
)
Built in Pagination Classes
LimitOffsetPagination (default)
This is the default pagination class (You can change it in your settings.py using
NINJA_PAGINATION_CLASS
path to a class)
from
ninja.pagination
import
paginate
,
LimitOffsetPagination
@api
.
get
(
'/users'
,
response
=
List
[
UserSchema
])
@paginate
(
LimitOffsetPagination
)
def
list_users
(
request
):
return
User
.
objects
.
all
()
Example query:
/api/users?limit=10&offset=0
this class has two input parameters:
limit
- defines a number of queryset on the page (default = 100, change in NINJA_PAGINATION_PER_PAGE)
offset
- set's the page window offset (default: 0, indexing starts with 0)
PageNumberPagination
from
ninja.pagination
import
paginate
,
PageNumberPagination
@api
.
get
(
'/users'
,
response
=
List
[
UserSchema
])
@paginate
(
PageNumberPagination
)
def
list_users
(
request
):
return
User
.
objects
.
all
()
Example query:
/api/users?page=2
this class has one parameter
page
and outputs 100 queryset per page by default  (can be changed with settings.py)
Page numbering start with 1
you can also set custom page_size value individually per view:
@api
.
get
(
"/users"
)
@paginate
(
PageNumberPagination
,
page_size
=
50
)
def
list_users
(
...
Accessing paginator parameters in view function
If you need access to
Input
parameters used for pagination in your view function - use
pass_parameter
argument
In that case input data will be available in
**kwargs
:
@api
.
get
(
"/someview"
)
@paginate
(
pass_parameter
=
"pagination_info"
)
def
someview
(
request
,
**
kwargs
):
page
=
kwargs
[
"pagination_info"
]
.
page
return
...
Creating Custom Pagination Class
To create a custom pagination class you should subclass
ninja.pagination.PaginationBase
and override the
Input
and
Output
schema classes and
paginate_queryset(self, queryset, request, **params)
method:
The
Input
schema is a Schema class that describes parameters that should be passed to your paginator (f.e. page-number or limit/offset values).
The
Output
schema describes schema for page output (f.e. count/next-page/items/etc).
The
paginate_queryset
method is passed the initial queryset and should return an iterable object that contains only the data in the requested page. This method accepts the following arguments:
queryset
: a queryset (or iterable) returned by the api function
pagination
- the paginator.Input parameters (parsed and validated)
**params
: kwargs that will contain all the arguments that decorated function received
Example:
from
ninja.pagination
import
paginate
,
PaginationBase
from
ninja
import
Schema
class
CustomPagination
(
PaginationBase
):
# only `skip` param, defaults to 5 per page
class
Input
(
Schema
):
skip
:
int
class
Output
(
Schema
):
items
:
List
[
Any
]
# `items` is a default attribute
total
:
int
per_page
:
int
def
paginate_queryset
(
self
,
queryset
,
pagination
:
Input
,
**
params
):
skip
=
pagination
.
skip
return
{
'items'
:
queryset
[
skip
:
skip
+
5
],
'total'
:
queryset
.
count
(),
'per_page'
:
5
,
}
@api
.
get
(
'/users'
,
response
=
List
[
UserSchema
])
@paginate
(
CustomPagination
)
def
list_users
(
request
):
return
User
.
objects
.
all
()
Tip: You can access request object from params:
def
paginate_queryset
(
self
,
queryset
,
pagination
:
Input
,
**
params
):
request
=
params
[
"request"
]
Output attribute
By defult page items are placed to
'items'
attribute. To override this behaviour use
items_attribute
:
class
CustomPagination
(
PaginationBase
):
...
class
Output
(
Schema
):
results
:
List
[
Any
]
total
:
int
per_page
:
int
items_attribute
:
str
=
"results"
Apply pagination to multiple operations at once
There is often a case when you need to add pagination to all views that returns querysets or list
You can use a builtin router class (
RouterPaginated
) that automatically injects pagination to all operations that defined
response=List[SomeSchema]
:
from
ninja.pagination
import
RouterPaginated
router
=
RouterPaginated
()
@router
.
get
(
"/items"
,
response
=
List
[
MySchema
])
def
items
(
request
):
return
MyModel
.
objects
.
all
()
@router
.
get
(
"/other-items"
,
response
=
List
[
OtherSchema
])
def
ohter_items
(
request
):
return
OtherModel
.
objects
.
all
()
In this example both operations will have pagination enabled
to apply pagination to main
api
instance use
default_router
argument:
api
=
NinjaAPI
(
default_router
=
RouterPaginated
())
@api
.
get
(
...
Previous
Overriding Pydantic Config
Next
Response renderers
Made with
Material for MkDocs
----------------------------------------
Title: Response renderers
Content:
Response renderers - Django Ninja
Skip to content
Django Ninja
Response renderers
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Response renderers
Table of contents
Create a renderer
ORJSON renderer example:
XML renderer example:
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Create a renderer
ORJSON renderer example:
XML renderer example:
Response renderers
The most common response type for a REST API is usually JSON.
Django Ninja
also has support for defining your own custom renderers, which gives you the flexibility to design your own media types.
Create a renderer
To create your own renderer, you need to inherit
ninja.renderers.BaseRenderer
and override the
render
method. Then you can pass an instance of your class to
NinjaAPI
as the
renderer
argument:
from
ninja
import
NinjaAPI
from
ninja.renderers
import
BaseRenderer
class
MyRenderer
(
BaseRenderer
):
media_type
=
"text/plain"
def
render
(
self
,
request
,
data
,
*
,
response_status
):
return
...
# your serialization here
api
=
NinjaAPI
(
renderer
=
MyRenderer
())
The
render
method takes the following arguments:
request -> HttpRequest object
data -> object that needs to be serialized
response_status as an
int
-> the HTTP status code that will be returned to the client
You need also define the
media_type
attribute on the class to set the content-type header for the response.
ORJSON renderer example:
orjson
is a fast, accurate JSON library for Python. It benchmarks as the fastest Python library for JSON and is more accurate than the standard
json
library or other third-party libraries. It also serializes dataclass, datetime, numpy, and UUID instances natively.
Here's an example renderer class that uses
orjson
:
import
orjson
from
ninja
import
NinjaAPI
from
ninja.renderers
import
BaseRenderer
class
ORJSONRenderer
(
BaseRenderer
):
media_type
=
"application/json"
def
render
(
self
,
request
,
data
,
*
,
response_status
):
return
orjson
.
dumps
(
data
)
api
=
NinjaAPI
(
renderer
=
ORJSONRenderer
())
XML renderer example:
This is how you create a renderer that outputs all responses as XML:
from
io
import
StringIO
from
django.utils.encoding
import
force_str
from
django.utils.xmlutils
import
SimplerXMLGenerator
from
ninja
import
NinjaAPI
from
ninja.renderers
import
BaseRenderer
class
XMLRenderer
(
BaseRenderer
):
media_type
=
"text/xml"
def
render
(
self
,
request
,
data
,
*
,
response_status
):
stream
=
StringIO
()
xml
=
SimplerXMLGenerator
(
stream
,
"utf-8"
)
xml
.
startDocument
()
xml
.
startElement
(
"data"
,
{})
self
.
_to_xml
(
xml
,
data
)
xml
.
endElement
(
"data"
)
xml
.
endDocument
()
return
stream
.
getvalue
()
def
_to_xml
(
self
,
xml
,
data
):
if
isinstance
(
data
,
(
list
,
tuple
)):
for
item
in
data
:
xml
.
startElement
(
"item"
,
{})
self
.
_to_xml
(
xml
,
item
)
xml
.
endElement
(
"item"
)
elif
isinstance
(
data
,
dict
):
for
key
,
value
in
data
.
items
():
xml
.
startElement
(
key
,
{})
self
.
_to_xml
(
xml
,
value
)
xml
.
endElement
(
key
)
elif
data
is
None
:
# Don't output any value
pass
else
:
xml
.
characters
(
force_str
(
data
))
api
=
NinjaAPI
(
renderer
=
XMLRenderer
())
(Copyright note: this code is basically copied from
DRF-xml
)
Previous
Pagination
Next
Splitting your API with Routers
Made with
Material for MkDocs
----------------------------------------
Title: Splitting your API with Routers
Content:
Splitting your API with Routers - Django Ninja
Skip to content
Django Ninja
Splitting your API with Routers
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Splitting your API with Routers
Table of contents
Router authentication
Router tags
Nested routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Router authentication
Router tags
Nested routers
Routers
Real world applications can almost never fit all logic into a single file.
Django Ninja
comes with an easy way to split your API into multiple modules using Routers.
Let's say you have a Django project with a structure like this:
├── myproject
│   └── settings.py
├── events/
│   ├── __init__.py
│   └── models.py
├── news/
│   ├── __init__.py
│   └── models.py
├── blogs/
│   ├── __init__.py
│   └── models.py
└── manage.py
To add API's to each of the Django applications, create an
api.py
module in each app:
├── myproject
│   └── settings.py
├── events/
│   ├── __init__.py
│   ├── api.py
│   └── models.py
├── news/
│   ├── __init__.py
│   ├── api.py
│   └── models.py
├── blogs/
│   ├── __init__.py
│   ├── api.py
│   └── models.py
└── manage.py
Now let's add a few operations to
events/api.py
. The trick is that instead of using the
NinjaAPI
class, you use the
Router
class:
from
ninja
import
Router
from
.models
import
Event
router
=
Router
()
@router
.
get
(
'/'
)
def
list_events
(
request
):
return
[
{
"id"
:
e
.
id
,
"title"
:
e
.
title
}
for
e
in
Event
.
objects
.
all
()
]
@router
.
get
(
'/
{event_id}
'
)
def
event_details
(
request
,
event_id
:
int
):
event
=
Event
.
objects
.
get
(
id
=
event_id
)
return
{
"title"
:
event
.
title
,
"details"
:
event
.
details
}
Then do the same for the
news
app with
news/api.py
:
from
ninja
import
Router
from
.models
import
News
router
=
Router
()
@router
.
get
(
'/'
)
def
list_news
(
request
):
...
@router
.
get
(
'/
{news_id}
'
)
def
news_details
(
request
,
news_id
:
int
):
...
and then also
blogs/api.py
.
Finally, let's group them together.
In your top level project folder (next to
urls.py
), create another
api.py
file with the main
NinjaAPI
instance:
├── myproject
│   ├── api.py
│   └── settings.py
├── events/
│   ...
├── news/
│   ...
├── blogs/
│   ...
It should look like this:
from
ninja
import
NinjaAPI
api
=
NinjaAPI
()
Now we import all the routers from the various apps, and include them into the main API instance:
from
ninja
import
NinjaAPI
from
events.api
import
router
as
events_router
api
=
NinjaAPI
()
api
.
add_router
(
"/events/"
,
events_router
)
# You can add a router as an object
api
.
add_router
(
"/news/"
,
"news.api.router"
)
#   or by Python path
api
.
add_router
(
"/blogs/"
,
"blogs.api.router"
)
Now, include
api
to your urls as usual and open your browser at
/api/docs
, and you should see all your routers combined into a single API:
Router authentication
Use
auth
argument to apply authenticator to all operations declared by router:
api
.
add_router
(
"/events/"
,
events_router
,
auth
=
BasicAuth
())
or using router constructor
router
=
Router
(
auth
=
BasicAuth
())
Router tags
You can use
tags
argument to apply tags to all operations declared by router:
api
.
add_router
(
"/events/"
,
events_router
,
tags
=
[
"events"
])
or using router constructor
router
=
Router
(
tags
=
[
"events"
])
Nested routers
There are also times when you need to split your logic up even more.
Django Ninja
makes it possible to include a router into another router as many times as you like, and finally include the top level router into the main
api
instance.
Basically, what that means is that you have
add_router
both on the
api
instance and on the
router
instance:
from
django.contrib
import
admin
from
django.urls
import
path
from
ninja
import
NinjaAPI
,
Router
api
=
NinjaAPI
()
first_router
=
Router
()
second_router
=
Router
()
third_router
=
Router
()
@api
.
get
(
"/add"
)
def
add
(
request
,
a
:
int
,
b
:
int
):
return
{
"result"
:
a
+
b
}
@first_router
.
get
(
"/add"
)
def
add
(
request
,
a
:
int
,
b
:
int
):
return
{
"result"
:
a
+
b
}
@second_router
.
get
(
"/add"
)
def
add
(
request
,
a
:
int
,
b
:
int
):
return
{
"result"
:
a
+
b
}
@third_router
.
get
(
"/add"
)
def
add
(
request
,
a
:
int
,
b
:
int
):
return
{
"result"
:
a
+
b
}
second_router
.
add_router
(
"l3"
,
third_router
)
first_router
.
add_router
(
"l2"
,
second_router
)
api
.
add_router
(
"l1"
,
first_router
)
urlpatterns
=
[
path
(
"admin/"
,
admin
.
site
.
urls
),
path
(
"api/"
,
api
.
urls
),
]
Now you have the following endpoints:
/api/add
/api/l1/add
/api/l1/l2/add
/api/l1/l2/l3/add
Great! Now go have a look at the automatically generated docs:
Previous
Response renderers
Next
Authentication
Made with
Material for MkDocs
----------------------------------------
Title: Authentication
Content:
Authentication - Django Ninja
Skip to content
Django Ninja
Authentication
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Authentication
Table of contents
Intro
Automatic OpenAPI schema
Global authentication
Available auth options
Custom function
API Key
in Query
in Header
in Cookie
HTTP Bearer
HTTP Basic Auth
Multiple authenticators
Router authentication
Custom exceptions
Async authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Intro
Automatic OpenAPI schema
Global authentication
Available auth options
Custom function
API Key
in Query
in Header
in Cookie
HTTP Bearer
HTTP Basic Auth
Multiple authenticators
Router authentication
Custom exceptions
Async authentication
Authentication
Intro
Django Ninja
provides several tools to help you deal with authentication and authorization easily, rapidly, in a standard way, and without having to study and learn
all the security specifications
.
The core concept is that when you describe an API operation, you can define an authentication object.
from
ninja
import
NinjaAPI
from
ninja.security
import
django_auth
api
=
NinjaAPI
(
csrf
=
True
)
@api
.
get
(
"/pets"
,
auth
=
django_auth
)
def
pets
(
request
):
return
f
"Authenticated user
{
request
.
auth
}
"
In this example, the client will only be able to call the
pets
method if it uses Django session authentication (the default is cookie based), otherwise an HTTP-401 error will be returned.
If you need to authorize only a superuser, you can use
from ninja.security import django_auth_superuser
instead.
Automatic OpenAPI schema
Here's an example where the client, in order to authenticate, needs to pass a header:
Authorization: Bearer supersecret
from
ninja.security
import
HttpBearer
class
AuthBearer
(
HttpBearer
):
def
authenticate
(
self
,
request
,
token
):
if
token
==
"supersecret"
:
return
token
@api
.
get
(
"/bearer"
,
auth
=
AuthBearer
())
def
bearer
(
request
):
return
{
"token"
:
request
.
auth
}
Now go to the docs at
http://localhost:8000/api/docs
.
Now, when you click the
Authorize
button, you will get a prompt to input your authentication token.
When you do test calls, the Authorization header will be passed for every request.
Global authentication
In case you need to secure
all
methods of your API, you can pass the
auth
argument to the
NinjaAPI
constructor:
from
ninja
import
NinjaAPI
,
Form
from
ninja.security
import
HttpBearer
class
GlobalAuth
(
HttpBearer
):
def
authenticate
(
self
,
request
,
token
):
if
token
==
"supersecret"
:
return
token
api
=
NinjaAPI
(
auth
=
GlobalAuth
())
# @api.get(...)
# def ...
# @api.post(...)
# def ...
And, if you need to overrule some of those methods, you can do that on the operation level again by passing the
auth
argument. In this example, authentication will be disabled for the
/token
operation:
from
ninja
import
NinjaAPI
,
Form
from
ninja.security
import
HttpBearer
class
GlobalAuth
(
HttpBearer
):
def
authenticate
(
self
,
request
,
token
):
if
token
==
"supersecret"
:
return
token
api
=
NinjaAPI
(
auth
=
GlobalAuth
())
# @api.get(...)
# def ...
# @api.post(...)
# def ...
@api
.
post
(
"/token"
,
auth
=
None
)
# < overriding global auth
def
get_token
(
request
,
username
:
str
=
Form
(
...
),
password
:
str
=
Form
(
...
)):
if
username
==
"admin"
and
password
==
"giraffethinnknslong"
:
return
{
"token"
:
"supersecret"
}
Available auth options
Custom function
The "
auth=
" argument accepts any Callable object.
NinjaAPI
passes authentication only if the callable object returns a value that can be
converted to boolean
True
. This return value will be assigned to the
request.auth
attribute.
def
ip_whitelist
(
request
):
if
request
.
META
[
"REMOTE_ADDR"
]
==
"8.8.8.8"
:
return
"8.8.8.8"
@api
.
get
(
"/ipwhitelist"
,
auth
=
ip_whitelist
)
def
ipwhitelist
(
request
):
return
f
"Authenticated client, IP =
{
request
.
auth
}
"
API Key
Some API's use API keys for authorization. An API key is a token that a client provides when making API calls to identify itself. The key can be sent in the query string:
GET /something?api_key=abcdef12345
or as a request header:
GET /something HTTP/1.1
X-API-Key: abcdef12345
or as a cookie:
GET /something HTTP/1.1
Cookie: X-API-KEY=abcdef12345
Django Ninja
comes with built-in classes to help you handle these cases.
in Query
from
ninja.security
import
APIKeyQuery
from
someapp.models
import
Client
class
ApiKey
(
APIKeyQuery
):
param_name
=
"api_key"
def
authenticate
(
self
,
request
,
key
):
try
:
return
Client
.
objects
.
get
(
key
=
key
)
except
Client
.
DoesNotExist
:
pass
api_key
=
ApiKey
()
@api
.
get
(
"/apikey"
,
auth
=
api_key
)
def
apikey
(
request
):
assert
isinstance
(
request
.
auth
,
Client
)
return
f
"Hello
{
request
.
auth
}
"
In this example we take a token from
GET['api_key']
and find a
Client
in the database that corresponds to this key. The Client instance will be set to the
request.auth
attribute.
Note:
param_name
is the name of the GET parameter that will be checked for. If not set, the default of "
key
" will be used.
in Header
from
ninja.security
import
APIKeyHeader
class
ApiKey
(
APIKeyHeader
):
param_name
=
"X-API-Key"
def
authenticate
(
self
,
request
,
key
):
if
key
==
"supersecret"
:
return
key
header_key
=
ApiKey
()
@api
.
get
(
"/headerkey"
,
auth
=
header_key
)
def
apikey
(
request
):
return
f
"Token =
{
request
.
auth
}
"
in Cookie
from
ninja.security
import
APIKeyCookie
class
CookieKey
(
APIKeyCookie
):
def
authenticate
(
self
,
request
,
key
):
if
key
==
"supersecret"
:
return
key
cookie_key
=
CookieKey
()
@api
.
get
(
"/cookiekey"
,
auth
=
cookie_key
)
def
apikey
(
request
):
return
f
"Token =
{
request
.
auth
}
"
HTTP Bearer
from
ninja.security
import
HttpBearer
class
AuthBearer
(
HttpBearer
):
def
authenticate
(
self
,
request
,
token
):
if
token
==
"supersecret"
:
return
token
@api
.
get
(
"/bearer"
,
auth
=
AuthBearer
())
def
bearer
(
request
):
return
{
"token"
:
request
.
auth
}
HTTP Basic Auth
from
ninja.security
import
HttpBasicAuth
class
BasicAuth
(
HttpBasicAuth
):
def
authenticate
(
self
,
request
,
username
,
password
):
if
username
==
"admin"
and
password
==
"secret"
:
return
username
@api
.
get
(
"/basic"
,
auth
=
BasicAuth
())
def
basic
(
request
):
return
{
"httpuser"
:
request
.
auth
}
Multiple authenticators
The
auth
argument also allows you to pass multiple authenticators:
from
ninja.security
import
APIKeyQuery
,
APIKeyHeader
class
AuthCheck
:
def
authenticate
(
self
,
request
,
key
):
if
key
==
"supersecret"
:
return
key
class
QueryKey
(
AuthCheck
,
APIKeyQuery
):
pass
class
HeaderKey
(
AuthCheck
,
APIKeyHeader
):
pass
@api
.
get
(
"/multiple"
,
auth
=
[
QueryKey
(),
HeaderKey
()])
def
multiple
(
request
):
return
f
"Token =
{
request
.
auth
}
"
In this case
Django Ninja
will first check the API key
GET
, and if not set or invalid will check the
header
key.
If both are invalid, it will raise an authentication error to the response.
Router authentication
Use
auth
argument on Router to apply authenticator to all operations declared in it:
api
.
add_router
(
"/events/"
,
events_router
,
auth
=
BasicAuth
())
or using router constructor
router
=
Router
(
auth
=
BasicAuth
())
Custom exceptions
Raising an exception that has an exception handler will return the response from that handler in
the same way an operation would:
from
ninja
import
NinjaAPI
from
ninja.security
import
HttpBearer
api
=
NinjaAPI
()
class
InvalidToken
(
Exception
):
pass
@api
.
exception_handler
(
InvalidToken
)
def
on_invalid_token
(
request
,
exc
):
return
api
.
create_response
(
request
,
{
"detail"
:
"Invalid token supplied"
},
status
=
401
)
class
AuthBearer
(
HttpBearer
):
def
authenticate
(
self
,
request
,
token
):
if
token
==
"supersecret"
:
return
token
raise
InvalidToken
@api
.
get
(
"/bearer"
,
auth
=
AuthBearer
())
def
bearer
(
request
):
return
{
"token"
:
request
.
auth
}
Async authentication
Django Ninja
has basic support for asynchronous authentication. While the default authentication classes are not async-compatible, you can still define your custom asynchronous authentication callables and pass them in using
auth
.
async
def
async_auth
(
request
):
...
@api
.
get
(
"/pets"
,
auth
=
async_auth
)
def
pets
(
request
):
...
See
Handling errors
for more information.
Previous
Splitting your API with Routers
Next
Testing
Made with
Material for MkDocs
----------------------------------------
Title: Testing
Content:
Testing - Django Ninja
Skip to content
Django Ninja
Testing
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Testing
Django Ninja
is fully compatible with standard
django test client
, but also provides a test client to make it easy to test just APIs without middleware/url-resolver layer making tests run faster.
To test the following API:
from
ninja
import
NinjaAPI
,
Schema
api
=
NinjaAPI
()
router
=
Router
()
class
HelloResponse
(
Schema
):
msg
:
str
@router
.
get
(
"/hello"
,
response
=
HelloResponse
)
def
hello
(
request
):
return
{
"msg"
:
"Hello World"
}
api
.
add_router
(
""
,
router
)
You can use the Django test class:
from
django.test
import
TestCase
from
ninja.testing
import
TestClient
class
HelloTest
(
TestCase
):
def
test_hello
(
self
):
client
=
NinjaTestClient
(
router
)
response
=
client
.
get
(
"/hello"
)
self
.
assertEqual
(
response
.
status_code
,
200
)
self
.
assertEqual
(
response
.
json
(),
{
"msg"
:
"Hello World"
})
Arbitrary attributes can be added to the request object by passing keyword arguments to the client request methods:
class
HelloTest
(
TestCase
):
def
test_hello
(
self
):
client
=
NinjaTestClient
(
router
)
# request.company_id will now be set within the view
response
=
client
.
get
(
"/hello"
,
company_id
=
1
)
Previous
Authentication
Next
API Docs
Made with
Material for MkDocs
----------------------------------------
Title: API Docs
Content:
API Docs - Django Ninja
Skip to content
Django Ninja
API Docs
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
API Docs
Table of contents
OpenAPI docs
CDN vs staticfiles
Switch to Redoc
Changing docs display settings
Hiding docs
Protecting docs
Extending OpenAPI Spec with custom attributes
Resolving the doc's url
Creating custom docs viewer
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
OpenAPI docs
CDN vs staticfiles
Switch to Redoc
Changing docs display settings
Hiding docs
Protecting docs
Extending OpenAPI Spec with custom attributes
Resolving the doc's url
Creating custom docs viewer
API Docs
OpenAPI docs
Once you configured your Ninja API and started runserver -  go to
http://127.0.0.1:8000/api/docs
You will see the automatic, interactive API documentation (provided by the
OpenAPI / Swagger UI
CDN vs staticfiles
You are not required to put django ninja to
INSTALLED_APPS
. In that case the interactive UI is hosted by CDN.
To host docs (Js/css) from your own server - just put "ninja" to INSTALLED_APPS - in that case standard django staticfiles mechanics will host it.
Switch to Redoc
from
ninja
import
Redoc
api
=
NinjaAPI
(
docs
=
Redoc
())
Then you will see the alternative automatic documentation (provided by
Redoc
).
Changing docs display settings
To set some custom settings for Swagger or Redocs you can use
settings
param on the docs class
from
ninja
import
Redoc
,
Swagger
api
=
NinjaAPI
(
docs
=
Swagger
(
settings
=
{
"persistAuthorization"
:
True
}))
...
api
=
NinjaAPI
(
docs
=
Redoc
(
settings
=
{
"disableSearch"
:
True
}))
Settings reference:
Swagger configuration
Redoc configuration
Hiding docs
In case you do not need to display interactive documentation - set
docs_url
argument to
None
api
=
NinjaAPI
(
docs_url
=
None
)
Protecting docs
To protect docs with authentication (or decorate for some other use case) use
docs_decorator
argument:
from
django.contrib.admin.views.decorators
import
staff_member_required
api
=
NinjaAPI
(
docs_decorator
=
staff_member_required
)
Extending OpenAPI Spec with custom attributes
You can extend OpenAPI spec with custom attributes, for example to add
termsOfService
api
=
NinjaAPI
(
openapi_extra
=
{
"info"
:
{
"termsOfService"
:
"https://example.com/terms/"
,
}
},
title
=
"Demo API"
,
description
=
"This is a demo API with dynamic OpenAPI info section"
)
Resolving the doc's url
The url for the api's documentation view can be reversed by referencing the view's name
openapi-view
.
In Python code, for example:
from
django.urls
import
reverse
reverse
(
'api-1.0.0:openapi-view'
)
>>>
'/api/docs'
In a Django template, for example:
<
a
href
=
"{% url 'api-1.0.0:openapi-view' %}"
>
API Docs
</
a
>
<
a
href
=
"/api/docs"
>
API Docs
</
a
>
Creating custom docs viewer
To create your own view for OpenaAPI - create a class inherited from DocsBase and overwrite
render_page
method:
form
ninja
.
openapi
.
docs
import
DocsBase
class
MyDocsViewer
(
DocsBase
)
def
render_page
(
self
,
request
,
api
):
...
# return http response
...
api
=
NinjaAPI
(
docs
=
MyDocsViewer
())
Previous
Testing
Next
Handling errors
Made with
Material for MkDocs
----------------------------------------
Title: Handling errors
Content:
Handling errors - Django Ninja
Skip to content
Django Ninja
Handling errors
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Handling errors
Table of contents
Custom exception handlers
Override the default exception handlers
ninja.errors.AuthenticationError
ninja.errors.ValidationError
ninja.errors.HttpError
django.http.Http404
Exception
Override default handler
Throwing HTTP responses with exceptions
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Custom exception handlers
Override the default exception handlers
ninja.errors.AuthenticationError
ninja.errors.ValidationError
ninja.errors.HttpError
django.http.Http404
Exception
Override default handler
Throwing HTTP responses with exceptions
Handling errors
Django Ninja
allows you to install custom exception handlers to deal with how you return responses when errors or handled exceptions occur.
Custom exception handlers
Let's say you are making API that depends on some external service that is designed to be unavailable at some moments. Instead of throwing default 500 error upon exception - you can handle the error and give some friendly response back to the client (to come back later)
To achieve that you need:
1) create some exception (or use existing one)
2) use api.exception_handler decorator
Example:
api
=
NinjaAPI
()
class
ServiceUnavailableError
(
Exception
):
pass
# initializing handler
@api
.
exception_handler
(
ServiceUnavailableError
)
def
service_unavailable
(
request
,
exc
):
return
api
.
create_response
(
request
,
{
"message"
:
"Please retry later"
},
status
=
503
,
)
# some logic that throws exception
@api
.
get
(
"/service"
)
def
some_operation
(
request
):
if
random
.
choice
([
True
,
False
]):
raise
ServiceUnavailableError
()
return
{
"message"
:
"Hello"
}
Exception handler function takes 2 arguments:
request
- Django http request
exc
- actual exception
function must return http response
Override the default exception handlers
By default,
Django Ninja
initialized the following exception handlers:
ninja.errors.AuthenticationError
Raised when authentication data is not valid
ninja.errors.ValidationError
Raised when request data does not validate
ninja.errors.HttpError
Used to throw http error with status code from any place of the code
django.http.Http404
Django's default 404 exception (can be returned f.e. with
get_object_or_404
)
Exception
Any other unhandled exception by application.
Default behavior
if
settings.DEBUG
is
True
- returns a traceback in plain text (useful when debugging in console or swagger UI)
else
- default django exception handler mechanism is used (error logging, email to ADMINS)
Override default handler
If you need to change default output for validation errors - override ValidationError exception handler:
from
ninja.errors
import
ValidationError
...
@api
.
exception_handler
(
ValidationError
)
def
validation_errors
(
request
,
exc
):
return
HttpResponse
(
"Invalid input"
,
status
=
422
)
Throwing HTTP responses with exceptions
As an alternative to custom exceptions and writing handlers for it - you can as well throw http exception that will lead to returning a http response with desired code
from
ninja.errors
import
HttpError
@api
.
get
(
"/some/resource"
)
def
some_operation
(
request
):
if
True
:
raise
HttpError
(
503
,
"Service Unavailable. Please retry later."
)
Previous
API Docs
Next
Reverse Resolution of URLS
Made with
Material for MkDocs
----------------------------------------
Title: Reverse Resolution of URLS
Content:
Reverse Resolution of URLS - Django Ninja
Skip to content
Django Ninja
Reverse Resolution of URLS
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Reverse Resolution of URLS
Table of contents
How URLs are generated
Changing the URL name
Overriding default url names
Customizing the namespace
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
How URLs are generated
Changing the URL name
Overriding default url names
Customizing the namespace
Reverse Resolution of URLS
A reverse URL name is generated for each method in a Django Ninja Schema (or
Router
).
How URLs are generated
The URLs are all contained within a namespace, which defaults to
"api-1.0.0"
, and each URL name matches the function it is decorated.
For example:
api
=
NinjaAPI
()
@api
.
get
(
"/"
)
def
index
(
request
):
...
index_url
=
reverse_lazy
(
"api-1.0.0:index"
)
This implicit URL name will only be set for the first operation for each API path.  If you
don't
want any implicit reverse URL name generated, just explicitly specify
url_name=""
(an empty string) on the method decorator.
Changing the URL name
Rather than using the default URL name, you can specify it explicitly as a property on the method decorator.
@api
.
get
(
"/users"
,
url_name
=
"user_list"
)
def
users
(
request
):
...
users_url
=
reverse_lazy
(
"api-1.0.0:user_list"
)
This will override any implicit URL name to this API path.
Overriding default url names
You can also override implicit url naming by overwriting the
get_operation_url_name
method:
class
MyAPI
(
NinjaAPI
):
def
get_operation_url_name
(
self
,
operation
,
router
):
return
operation
.
view_func
.
__name__
+
'_my_extra_suffix'
api
=
MyAPI
()
Customizing the namespace
The default URL namespace is built by prepending the Schema's version with
"api-"
, however you can explicitly specify the namespace by overriding the
urls_namespace
attribute of the
NinjaAPI
Schema class.
api
=
NinjaAPI
(
auth
=
token_auth
,
version
=
'2'
)
api_private
=
NinjaAPI
(
auth
=
session_auth
,
urls_namespace
=
'private_api'
)
api_users_url
=
reverse_lazy
(
"api-2:users"
)
private_api_admins_url
=
reverse_lazy
(
"private_api:admins"
)
Previous
Handling errors
Next
Async support
Made with
Material for MkDocs
----------------------------------------
Title: Async support
Content:
Async support - Django Ninja
Skip to content
Django Ninja
Async support
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Async support
Table of contents
Intro
Quick example
Code
Run
Test
Mixing sync and async operations
Elasticsearch example
Using ORM
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Intro
Quick example
Code
Run
Test
Mixing sync and async operations
Elasticsearch example
Using ORM
Async support
Intro
Since
version 3.1
, Django comes with
async views support
. This allows you run efficient concurrent views that are network and/or IO bound.
pip install Django>=3.1 django-ninja
Async views work more efficiently when it comes to:
calling external APIs over the network
executing/waiting for database queries
reading/writing from/to disk drives
Django Ninja
takes full advantage of async views and makes it very easy to work with them.
Quick example
Code
Let's take an example.  We have an API operation that does some work (currently just sleeps for provided number of seconds) and returns a word:
import
time
@api
.
get
(
"/say-after"
)
def
say_after
(
request
,
delay
:
int
,
word
:
str
):
time
.
sleep
(
delay
)
return
{
"saying"
:
word
}
To make this code asynchronous, all you have to do is add the
async
keyword to a function (and use async aware libraries for work processing - in our case we will replace the stdlib
sleep
with
asyncio.sleep
):
import
asyncio
@api
.
get
(
"/say-after"
)
async
def
say_after
(
request
,
delay
:
int
,
word
:
str
):
await
asyncio
.
sleep
(
delay
)
return
{
"saying"
:
word
}
Run
To run this code you need an ASGI server like
Uvicorn
or
Daphne
. Let's use Uvicorn for, example:
To install Uvicorn, use:
pip install uvicorn
Then start the server:
uvicorn your_project.asgi:application --reload
Note: replace
your_project
with your project package name
--reload
flag used to automatically reload server if you do any changes to the code (do not use on production)
Note
You can run async views with
manage.py runserver
, but it does not work well with some libraries, so at this time (July 2020) it is recommended to use ASGI servers like Uvicorn or Daphne.
Test
Go to your browser and open
http://127.0.0.1:8000/api/say-after?delay=3&word=hello
(
delay=3
)
After a 3-second wait you should see the "hello" message.
Now let's flood this operation with
100 parallel requests
:
ab -c 100 -n 100 "http://127.0.0.1:8000/api/say-after?delay=3&word=hello"
which will result in something like this:
Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    1   1.1      1       4
Processing:  3008 3063  16.2   3069    3082
Waiting:     3008 3062  15.7   3068    3079
Total:       3008 3065  16.3   3070    3083

Percentage of the requests served within a certain time (ms)
  50%   3070
  66%   3072
  75%   3075
  80%   3076
  90%   3081
  95%   3082
  98%   3083
  99%   3083
 100%   3083 (longest request)
Based on the numbers, our service was able to handle each of the 100 concurrent requests with just a little overhead.
To achieve the same concurrency with WSGI and sync operations you would need to spin up about 10 workers with 10 threads each!
Mixing sync and async operations
Keep in mind that you can use
both sync and async operations
in your project, and
Django Ninja
will route it automatically:
@api
.
get
(
"/say-sync"
)
def
say_after_sync
(
request
,
delay
:
int
,
word
:
str
):
time
.
sleep
(
delay
)
return
{
"saying"
:
word
}
@api
.
get
(
"/say-async"
)
async
def
say_after_async
(
request
,
delay
:
int
,
word
:
str
):
await
asyncio
.
sleep
(
delay
)
return
{
"saying"
:
word
}
Elasticsearch example
Let's take a real world use case. For this example, let's use the latest version of Elasticsearch that now comes with async support:
pip install elasticsearch>=7.8.0
And now instead of the
Elasticsearch
class, use the
AsyncElasticsearch
class and
await
the results:
from
ninja
import
NinjaAPI
from
elasticsearch
import
AsyncElasticsearch
api
=
NinjaAPI
()
es
=
AsyncElasticsearch
()
@api
.
get
(
"/search"
)
async
def
search
(
request
,
q
:
str
):
resp
=
await
es
.
search
(
index
=
"documents"
,
body
=
{
"query"
:
{
"query_string"
:
{
"query"
:
q
}}},
size
=
20
,
)
return
resp
[
"hits"
]
Using ORM
Currently, certain key parts of Django are not able to operate safely in an async environment, as they have global state that is not coroutine-aware. These parts of Django are classified as “async-unsafe”, and are protected from execution in an async environment.
The ORM
is the main example, but there are other parts that are also protected in this way.
Learn more about async safety here in the
official Django docs
.
So, if you do this:
@api
.
get
(
"/blog/
{post_id}
"
)
async
def
search
(
request
,
post_id
:
int
):
blog
=
Blog
.
objects
.
get
(
pk
=
post_id
)
...
it throws an error. Until the async ORM is implemented, you can use the
sync_to_async()
adapter:
from
asgiref.sync
import
sync_to_async
@sync_to_async
def
get_blog
(
post_id
):
return
Blog
.
objects
.
get
(
pk
=
post_id
)
@api
.
get
(
"/blog/
{post_id}
"
)
async
def
search
(
request
,
post_id
:
int
):
blog
=
await
get_blog
(
post_id
)
...
or even shorter:
@api
.
get
(
"/blog/
{post_id}
"
)
async
def
search
(
request
,
post_id
:
int
):
blog
=
await
sync_to_async
(
Blog
.
objects
.
get
)(
pk
=
post_id
)
...
There is a common
GOTCHA
: Django queryset's are lazily evaluated (database query happens only when you start iterating), so this will
not
work:
all_blogs
=
await
sync_to_async
(
Blog
.
objects
.
all
)()
# it will throw an error later when you try to iterate over all_blogs
...
Instead, use evaluation (with
list
):
all_blogs
=
await
sync_to_async
(
list
)(
Blog
.
objects
.
all
())
...
Since Django
version 4.1
, Django comes with asynchronous versions of ORM operations.
These eliminate the need to use
sync_to_async
in most cases.
The async operations have the same names as their sync counterparts but are prepended with
a
. So using
the example above, you can rewrite it as:
@api
.
get
(
"/blog/
{post_id}
"
)
async
def
search
(
request
,
post_id
:
int
):
blog
=
await
Blog
.
objects
.
aget
(
pk
=
post_id
)
...
When working with querysets, use
async for
paired with list comprehension:
all_blogs
=
[
blog
async
for
blog
in
Blog
.
objects
.
all
()]
...
Learn more about the async ORM interface in the
official Django docs
.
Previous
Reverse Resolution of URLS
Next
Versioning
Made with
Material for MkDocs
----------------------------------------
Title: Versioning
Content:
Versioning - Django Ninja
Skip to content
Django Ninja
Versioning
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Versioning
Table of contents
Different API version numbers
Different business logic
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Different API version numbers
Different business logic
Versioning
Different API version numbers
With
Django Ninja
it's easy to run multiple API versions from a single Django project.
All you have to do is create two or more NinjaAPI instances with different
version
arguments:
api_v1.py
:
from
ninja
import
NinjaAPI
api
=
NinjaAPI
(
version
=
'1.0.0'
)
@api
.
get
(
'/hello'
)
def
hello
(
request
):
return
{
'message'
:
'Hello from V1'
}
api_
v2
.py:
from
ninja
import
NinjaAPI
api
=
NinjaAPI
(
version
=
'2.0.0'
)
@api
.
get
(
'/hello'
)
def
hello
(
request
):
return
{
'message'
:
'Hello from V2'
}
and then in
urls.py
:
...
from
api_v1
import
api
as
api_v1
from
api_v2
import
api
as
api_v2
urlpatterns
=
[
...
path
(
'api/v1/'
,
api_v1
.
urls
),
path
(
'api/v2/'
,
api_v2
.
urls
),
]
Now you can go to different OpenAPI docs pages for each version:
http://127.0.0.1/api/
v1
/docs
http://127.0.0.1/api/
v2
/docs
Different business logic
In the same way, you can define a different API for different components or areas:
...
api
=
NinjaAPI
(
auth
=
token_auth
,
urls_namespace
=
'public_api'
)
...
api_private
=
NinjaAPI
(
auth
=
session_auth
,
urls_namespace
=
'private_api'
)
...
urlpatterns
=
[
...
path
(
'api/'
,
api
.
urls
),
path
(
'internal-api/'
,
api_private
.
urls
),
]
Note
If you use different
NinjaAPI
instances, you need to define different
version
s or different
urls_namespace
s.
Previous
Async support
Next
NinjaAPI class
Made with
Material for MkDocs
----------------------------------------
Title: NinjaAPI class
Content:
NinjaAPI class - Django Ninja
Skip to content
Django Ninja
NinjaAPI class
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
NinjaAPI class
Table of contents
NinjaAPI
__init__
delete
get
get_operation_url_name
patch
post
put
urls
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
NinjaAPI
__init__
delete
get
get_operation_url_name
patch
post
put
urls
NinjaAPI
Ninja API
Source code in
ninja/main.py
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
class
NinjaAPI
:
"""
Ninja API
"""
_registry
:
List
[
str
]
=
[]
def
__init__
(
self
,
*
,
title
:
str
=
"NinjaAPI"
,
version
:
str
=
"1.0.0"
,
description
:
str
=
""
,
openapi_url
:
Optional
[
str
]
=
"/openapi.json"
,
docs
:
DocsBase
=
Swagger
(),
docs_url
:
Optional
[
str
]
=
"/docs"
,
docs_decorator
:
Optional
[
Callable
[[
TCallable
],
TCallable
]]
=
None
,
servers
:
Optional
[
List
[
DictStrAny
]]
=
None
,
urls_namespace
:
Optional
[
str
]
=
None
,
csrf
:
bool
=
False
,
auth
:
Optional
[
Union
[
Sequence
[
Callable
],
Callable
,
NOT_SET_TYPE
]]
=
NOT_SET
,
renderer
:
Optional
[
BaseRenderer
]
=
None
,
parser
:
Optional
[
Parser
]
=
None
,
default_router
:
Optional
[
Router
]
=
None
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
):
"""
Args:
title: A title for the api.
description: A description for the api.
version: The API version.
urls_namespace: The Django URL namespace for the API. If not provided, the namespace will be ``"api-" + self.version``.
openapi_url: The relative URL to serve the openAPI spec.
openapi_extra: Additional attributes for the openAPI spec.
docs_url: The relative URL to serve the API docs.
servers: List of target hosts used in openAPI spec.
csrf: Require a CSRF token for unsafe request types. See <a href="../csrf">CSRF</a> docs.
auth (Callable | Sequence[Callable] | NOT_SET | None): Authentication class
renderer: Default response renderer
parser: Default request parser
"""
self
.
title
=
title
self
.
version
=
version
self
.
description
=
description
self
.
openapi_url
=
openapi_url
self
.
docs
=
docs
self
.
docs_url
=
docs_url
self
.
docs_decorator
=
docs_decorator
self
.
servers
=
servers
or
[]
self
.
urls_namespace
=
urls_namespace
or
f
"api-
{
self
.
version
}
"
self
.
csrf
=
csrf
# TODO: Check if used or at least throw Deprecation warning
if
self
.
csrf
:
warnings
.
warn
(
"csrf argument is deprecated, auth is handling csrf automatically now"
,
DeprecationWarning
,
stacklevel
=
2
,
)
self
.
renderer
=
renderer
or
JSONRenderer
()
self
.
parser
=
parser
or
Parser
()
self
.
openapi_extra
=
openapi_extra
or
{}
self
.
_exception_handlers
:
Dict
[
Exc
,
ExcHandler
]
=
{}
self
.
set_default_exception_handlers
()
self
.
auth
:
Optional
[
Union
[
Sequence
[
Callable
],
NOT_SET_TYPE
]]
if
callable
(
auth
):
self
.
auth
=
[
auth
]
else
:
self
.
auth
=
auth
self
.
_routers
:
List
[
Tuple
[
str
,
Router
]]
=
[]
self
.
default_router
=
default_router
or
Router
()
self
.
add_router
(
""
,
self
.
default_router
)
def
get
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`GET` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
get
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
def
post
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`POST` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
post
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
def
delete
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`DELETE` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
delete
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
def
patch
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`PATCH` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
patch
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
def
put
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`PUT` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
put
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
def
api_operation
(
self
,
methods
:
List
[
str
],
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
return
self
.
default_router
.
api_operation
(
methods
,
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
def
add_router
(
self
,
prefix
:
str
,
router
:
Union
[
Router
,
str
],
*
,
auth
:
Any
=
NOT_SET
,
tags
:
Optional
[
List
[
str
]]
=
None
,
parent_router
:
Optional
[
Router
]
=
None
,
)
->
None
:
if
isinstance
(
router
,
str
):
router
=
import_string
(
router
)
assert
isinstance
(
router
,
Router
)
if
auth
is
not
NOT_SET
:
router
.
auth
=
auth
if
tags
is
not
None
:
router
.
tags
=
tags
if
parent_router
:
parent_prefix
=
next
(
(
path
for
path
,
r
in
self
.
_routers
if
r
is
parent_router
),
None
)
# pragma: no cover
assert
parent_prefix
is
not
None
prefix
=
normalize_path
(
"/"
.
join
((
parent_prefix
,
prefix
)))
.
lstrip
(
"/"
)
self
.
_routers
.
extend
(
router
.
build_routers
(
prefix
))
router
.
set_api_instance
(
self
,
parent_router
)
@property
def
urls
(
self
)
->
Tuple
[
List
[
Union
[
URLResolver
,
URLPattern
]],
str
,
str
]:
"""
str: URL configuration
Returns:
Django URL configuration
"""
self
.
_validate
()
return
(
self
.
_get_urls
(),
"ninja"
,
self
.
urls_namespace
.
split
(
":"
)[
-
1
],
# ^ if api included into nested urls, we only care about last bit here
)
def
_get_urls
(
self
)
->
List
[
Union
[
URLResolver
,
URLPattern
]]:
result
=
get_openapi_urls
(
self
)
for
prefix
,
router
in
self
.
_routers
:
result
.
extend
(
router
.
urls_paths
(
prefix
))
result
.
append
(
get_root_url
(
self
))
return
result
def
get_root_path
(
self
,
path_params
:
DictStrAny
)
->
str
:
name
=
f
"
{
self
.
urls_namespace
}
:api-root"
return
reverse
(
name
,
kwargs
=
path_params
)
def
create_response
(
self
,
request
:
HttpRequest
,
data
:
Any
,
*
,
status
:
Optional
[
int
]
=
None
,
temporal_response
:
Optional
[
HttpResponse
]
=
None
,
)
->
HttpResponse
:
if
temporal_response
:
status
=
temporal_response
.
status_code
assert
status
content
=
self
.
renderer
.
render
(
request
,
data
,
response_status
=
status
)
if
temporal_response
:
response
=
temporal_response
response
.
content
=
content
else
:
response
=
HttpResponse
(
content
,
status
=
status
,
content_type
=
self
.
get_content_type
()
)
return
response
def
create_temporal_response
(
self
,
request
:
HttpRequest
)
->
HttpResponse
:
return
HttpResponse
(
""
,
content_type
=
self
.
get_content_type
())
def
get_content_type
(
self
)
->
str
:
return
f
"
{
self
.
renderer
.
media_type
}
; charset=
{
self
.
renderer
.
charset
}
"
def
get_openapi_schema
(
self
,
*
,
path_prefix
:
Optional
[
str
]
=
None
,
path_params
:
Optional
[
DictStrAny
]
=
None
,
)
->
OpenAPISchema
:
if
path_prefix
is
None
:
path_prefix
=
self
.
get_root_path
(
path_params
or
{})
return
get_schema
(
api
=
self
,
path_prefix
=
path_prefix
)
def
get_openapi_operation_id
(
self
,
operation
:
"Operation"
)
->
str
:
name
=
operation
.
view_func
.
__name__
module
=
operation
.
view_func
.
__module__
return
(
module
+
"_"
+
name
)
.
replace
(
"."
,
"_"
)
def
get_operation_url_name
(
self
,
operation
:
"Operation"
,
router
:
Router
)
->
str
:
"""
Get the default URL name to use for an operation if it wasn't
explicitly provided.
"""
return
operation
.
view_func
.
__name__
def
add_exception_handler
(
self
,
exc_class
:
Type
[
Exception
],
handler
:
ExcHandler
)
->
None
:
assert
issubclass
(
exc_class
,
Exception
)
self
.
_exception_handlers
[
exc_class
]
=
handler
def
exception_handler
(
self
,
exc_class
:
Type
[
Exception
])
->
Callable
[
...
,
Any
]:
def
decorator
(
func
:
Callable
)
->
Callable
:
self
.
add_exception_handler
(
exc_class
,
func
)
return
func
return
decorator
def
set_default_exception_handlers
(
self
)
->
None
:
set_default_exc_handlers
(
self
)
def
on_exception
(
self
,
request
:
HttpRequest
,
exc
:
Exc
)
->
HttpResponse
:
handler
=
self
.
_lookup_exception_handler
(
exc
)
if
handler
is
None
:
raise
exc
return
handler
(
request
,
exc
)
def
_lookup_exception_handler
(
self
,
exc
:
Exc
)
->
Optional
[
ExcHandler
]:
for
cls
in
type
(
exc
)
.
__mro__
:
if
cls
in
self
.
_exception_handlers
:
return
self
.
_exception_handlers
[
cls
]
return
None
def
_validate
(
self
)
->
None
:
# urls namespacing validation
skip_registry
=
os
.
environ
.
get
(
"NINJA_SKIP_REGISTRY"
,
False
)
if
(
not
skip_registry
and
self
.
urls_namespace
in
NinjaAPI
.
_registry
and
not
debug_server_url_reimport
()
):
msg
=
f
"""
Looks like you created multiple NinjaAPIs or TestClients
To let ninja distinguish them you need to set either unique version or urls_namespace
- NinjaAPI(..., version='2.0.0')
- NinjaAPI(..., urls_namespace='otherapi')
Already registered:
{
NinjaAPI
.
_registry
}
"""
raise
ConfigError
(
msg
.
strip
())
NinjaAPI
.
_registry
.
append
(
self
.
urls_namespace
)
__init__
Parameters:
Name
Type
Description
Default
title
str
A title for the api.
'NinjaAPI'
description
str
A description for the api.
''
version
str
The API version.
'1.0.0'
urls_namespace
Optional
[str]
The Django URL namespace for the API. If not provided, the namespace will be
"api-" + self.version
.
None
openapi_url
Optional
[str]
The relative URL to serve the openAPI spec.
'/openapi.json'
openapi_extra
Optional
[
Dict
[str,
Any
]]
Additional attributes for the openAPI spec.
None
docs_url
Optional
[str]
The relative URL to serve the API docs.
'/docs'
servers
Optional
[
List
[
DictStrAny
]]
List of target hosts used in openAPI spec.
None
csrf
bool
Require a CSRF token for unsafe request types. See
CSRF
docs.
False
auth
Callable
|
Sequence
[
Callable
] |
NOT_SET
| None
Authentication class
NOT_SET
renderer
Optional
[
BaseRenderer
]
Default response renderer
None
parser
Optional
[
Parser
]
Default request parser
None
Source code in
ninja/main.py
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
def
__init__
(
self
,
*
,
title
:
str
=
"NinjaAPI"
,
version
:
str
=
"1.0.0"
,
description
:
str
=
""
,
openapi_url
:
Optional
[
str
]
=
"/openapi.json"
,
docs
:
DocsBase
=
Swagger
(),
docs_url
:
Optional
[
str
]
=
"/docs"
,
docs_decorator
:
Optional
[
Callable
[[
TCallable
],
TCallable
]]
=
None
,
servers
:
Optional
[
List
[
DictStrAny
]]
=
None
,
urls_namespace
:
Optional
[
str
]
=
None
,
csrf
:
bool
=
False
,
auth
:
Optional
[
Union
[
Sequence
[
Callable
],
Callable
,
NOT_SET_TYPE
]]
=
NOT_SET
,
renderer
:
Optional
[
BaseRenderer
]
=
None
,
parser
:
Optional
[
Parser
]
=
None
,
default_router
:
Optional
[
Router
]
=
None
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
):
"""
Args:
title: A title for the api.
description: A description for the api.
version: The API version.
urls_namespace: The Django URL namespace for the API. If not provided, the namespace will be ``"api-" + self.version``.
openapi_url: The relative URL to serve the openAPI spec.
openapi_extra: Additional attributes for the openAPI spec.
docs_url: The relative URL to serve the API docs.
servers: List of target hosts used in openAPI spec.
csrf: Require a CSRF token for unsafe request types. See <a href="../csrf">CSRF</a> docs.
auth (Callable | Sequence[Callable] | NOT_SET | None): Authentication class
renderer: Default response renderer
parser: Default request parser
"""
self
.
title
=
title
self
.
version
=
version
self
.
description
=
description
self
.
openapi_url
=
openapi_url
self
.
docs
=
docs
self
.
docs_url
=
docs_url
self
.
docs_decorator
=
docs_decorator
self
.
servers
=
servers
or
[]
self
.
urls_namespace
=
urls_namespace
or
f
"api-
{
self
.
version
}
"
self
.
csrf
=
csrf
# TODO: Check if used or at least throw Deprecation warning
if
self
.
csrf
:
warnings
.
warn
(
"csrf argument is deprecated, auth is handling csrf automatically now"
,
DeprecationWarning
,
stacklevel
=
2
,
)
self
.
renderer
=
renderer
or
JSONRenderer
()
self
.
parser
=
parser
or
Parser
()
self
.
openapi_extra
=
openapi_extra
or
{}
self
.
_exception_handlers
:
Dict
[
Exc
,
ExcHandler
]
=
{}
self
.
set_default_exception_handlers
()
self
.
auth
:
Optional
[
Union
[
Sequence
[
Callable
],
NOT_SET_TYPE
]]
if
callable
(
auth
):
self
.
auth
=
[
auth
]
else
:
self
.
auth
=
auth
self
.
_routers
:
List
[
Tuple
[
str
,
Router
]]
=
[]
self
.
default_router
=
default_router
or
Router
()
self
.
add_router
(
""
,
self
.
default_router
)
delete
DELETE
operation. See
operations
parameters
reference.
Source code in
ninja/main.py
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
def
delete
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`DELETE` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
delete
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
get
GET
operation. See
operations
parameters
reference.
Source code in
ninja/main.py
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
def
get
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`GET` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
get
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
get_operation_url_name
Get the default URL name to use for an operation if it wasn't
explicitly provided.
Source code in
ninja/main.py
463
464
465
466
467
468
def
get_operation_url_name
(
self
,
operation
:
"Operation"
,
router
:
Router
)
->
str
:
"""
Get the default URL name to use for an operation if it wasn't
explicitly provided.
"""
return
operation
.
view_func
.
__name__
patch
PATCH
operation. See
operations
parameters
reference.
Source code in
ninja/main.py
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
def
patch
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`PATCH` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
patch
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
post
POST
operation. See
operations
parameters
reference.
Source code in
ninja/main.py
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
def
post
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`POST` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
post
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
put
PUT
operation. See
operations
parameters
reference.
Source code in
ninja/main.py
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
def
put
(
self
,
path
:
str
,
*
,
auth
:
Any
=
NOT_SET
,
response
:
Any
=
NOT_SET
,
operation_id
:
Optional
[
str
]
=
None
,
summary
:
Optional
[
str
]
=
None
,
description
:
Optional
[
str
]
=
None
,
tags
:
Optional
[
List
[
str
]]
=
None
,
deprecated
:
Optional
[
bool
]
=
None
,
by_alias
:
bool
=
False
,
exclude_unset
:
bool
=
False
,
exclude_defaults
:
bool
=
False
,
exclude_none
:
bool
=
False
,
url_name
:
Optional
[
str
]
=
None
,
include_in_schema
:
bool
=
True
,
openapi_extra
:
Optional
[
Dict
[
str
,
Any
]]
=
None
,
)
->
Callable
[[
TCallable
],
TCallable
]:
"""
`PUT` operation. See <a href="../operations-parameters">operations
parameters</a> reference.
"""
return
self
.
default_router
.
put
(
path
,
auth
=
auth
is
NOT_SET
and
self
.
auth
or
auth
,
response
=
response
,
operation_id
=
operation_id
,
summary
=
summary
,
description
=
description
,
tags
=
tags
,
deprecated
=
deprecated
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
url_name
=
url_name
,
include_in_schema
=
include_in_schema
,
openapi_extra
=
openapi_extra
,
)
urls
:
Tuple
[
List
[
Union
[
URLResolver
,
URLPattern
]],
str
,
str
]
property
str: URL configuration
Returns:
Django URL configuration
Previous
Versioning
Next
CSRF
Made with
Material for MkDocs
----------------------------------------
Title: CSRF
Content:
CSRF - Django Ninja
Skip to content
Django Ninja
CSRF
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
CSRF
Table of contents
What is CSRF?
How to protect against CSRF with Django Ninja
Use an authentication method not automatically embedded in the request
Use Django's built-in CSRF protection
Django ensure_csrf_cookie decorator
Frontend code
A word about CORS
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
What is CSRF?
How to protect against CSRF with Django Ninja
Use an authentication method not automatically embedded in the request
Use Django's built-in CSRF protection
Django ensure_csrf_cookie decorator
Frontend code
A word about CORS
CSRF
What is CSRF?
Cross Site Request Forgery
occurs when a malicious website contains a link, a form button or some JavaScript that is intended to perform some action on your website, using the credentials (or location on the network, not covered by this documentation) of a logged-in user who visits the malicious site in their browser.
How to protect against CSRF with Django Ninja
Use an authentication method not automatically embedded in the request
CSRF attacks rely on authentication methods that are automatically included in requests started from another site, like
cookies
or
Basic access authentication
.
Using an authentication method that does not automatically gets embedded, such as the
Authorization: Bearer
header for exemple, mitigates this attack.
Use Django's built-in CSRF protection
In case you are using the default Django authentication, which uses cookies, you must also use the default
Django CSRF protection
.
By default,
Django Ninja
has CSRF protection turned
OFF
for all operations.
To turn it on you need to use the
csrf
argument of the NinjaAPI class:
from
ninja
import
NinjaAPI
api
=
NinjaAPI
(
csrf
=
True
)
Warning
: It is not secure to use API's with cookie-based authentication! (like
CookieKey
, or
django_auth
) when csrf is turned OFF.
Django Ninja
will automatically enable csrf for Cookie based authentication
from
ninja
import
NinjaAPI
from
ninja.security
import
APIKeyCookie
class
CookieAuth
(
APIKeyCookie
):
def
authenticate
(
self
,
request
,
key
):
return
key
==
"test"
api
=
NinjaAPI
(
auth
=
CookieAuth
())
or django-auth based (which is inherited from cookie based auth):
from
ninja
import
NinjaAPI
from
ninja.security
import
django_auth
api
=
NinjaAPI
(
auth
=
django_auth
)
Django
ensure_csrf_cookie
decorator
You can use the Django
ensure_csrf_cookie
decorator on an unprotected route to make it include a
Set-Cookie
header for the CSRF token. Note that:
- The route decorator must be executed before (i.e. above) the
ensure_csrf_cookie
decorator).
- You must
csrf_exempt
that route.
- The
ensure_csrf_cookie
decorator works only on a Django
HttpResponse
and not also on a dict like most Django Ninja decorators.
from
django.http
import
HttpResponse
from
django.views.decorators.csrf
import
csrf_exempt
,
ensure_csrf_cookie
@api
.
post
(
"/csrf"
)
@ensure_csrf_cookie
@csrf_exempt
def
get_csrf_token
(
request
):
return
HttpResponse
()
A request to that route triggers a response with the adequate
Set-Cookie
header from Django.
Frontend code
You may use the
Using CSRF protection with AJAX
and
Setting the token on the AJAX request
part of the
How to use Django’s CSRF protection
to know how to handle that CSRF protection token in your frontend code.
A word about CORS
You may want to set-up your frontend and API on different sites (in that case, you may check
django-cors-headers
).
While not directly related to CSRF, CORS (Cross-Origin Resource Sharing) may help in case you are defining the CSRF cookie on another site than the frontend consuming it, as this is not allowed by default by the
Same-origin policy
.
You may check the
django-cors-headers README
then.
Previous
NinjaAPI class
Next
Operations parameters
Made with
Material for MkDocs
----------------------------------------
Title: Operations parameters
Content:
Operations parameters - Django Ninja
Skip to content
Django Ninja
Operations parameters
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Operations parameters
Table of contents
OpenAPI Schema related
tags
Router tags
summary
description
operation_id
deprecated
include_in_schema
openapi_extra
Response output options
by_alias
exclude_unset
exclude_defaults
exclude_none
url_name
Specifying servers
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
OpenAPI Schema related
tags
Router tags
summary
description
operation_id
deprecated
include_in_schema
openapi_extra
Response output options
by_alias
exclude_unset
exclude_defaults
exclude_none
url_name
Specifying servers
Operations parameters
OpenAPI Schema related
The following parameters interact with the how the OpenAPI schema (and docs) are generated.
tags
You can group your API operations using the
tags
argument (
list[str]
).
@api
.
get
(
"/hello/"
)
def
hello
(
request
,
name
:
str
):
return
{
"hello"
:
name
}
@api
.
post
(
"/orders/"
,
tags
=
[
"orders"
])
def
create_order
(
request
,
order
:
Order
):
return
{
"success"
:
True
}
Tagged operations may be handled differently by various tools and libraries. For example, the Swagger UI uses tags to group the displayed operations.
Router tags
You can use
tags
argument to apply tags to all operations declared by router:
api
.
add_router
(
"/events/"
,
events_router
,
tags
=
[
"events"
])
# or using constructor:
router
=
Router
(
tags
=
[
"events"
])
summary
A human-readable name for your operation.
By default, it's generated by capitalizing your operation function name:
@api
.
get
(
"/hello/"
)
def
hello
(
request
,
name
:
str
):
return
{
"hello"
:
name
}
If you want to override it or translate it to other language, use the
summary
argument in the
api
decorator.
@api
.
get
(
"/hello/"
,
summary
=
"Say Hello"
)
def
hello
(
request
,
name
:
str
):
return
{
"hello"
:
name
}
description
To provide more information about your operation, use either the
description
argument or normal Python docstrings:
@api
.
post
(
"/orders/"
,
description
=
"Creates an order and updates stock"
)
def
create_order
(
request
,
order
:
Order
):
return
{
"success"
:
True
}
When you need to provide a long multi line description, you can use Python
docstrings
for the function definition:
@api
.
post
(
"/orders/"
)
def
create_order
(
request
,
order
:
Order
):
"""
To create an order please provide:
- **first_name**
- **last_name**
- and **list of Items** *(product + amount)*
"""
return
{
"success"
:
True
}
operation_id
The OpenAPI
operationId
is an optional unique string used to identify an operation. If provided, these IDs must be unique among all operations described in your API.
By default,
Django Ninja
sets it to
module name
+
function name
.
If you want to set it individually for each operation, use the
operation_id
argument:
...
@api
.
post
(
"/tasks"
,
operation_id
=
"create_task"
)
def
new_task
(
request
):
...
If you want to override global behavior, you can inherit the NinjaAPI instance and override the
get_openapi_operation_id
method.
It will be called for each operation that you defined, so you can set your custom naming logic like this:
from
ninja
import
NinjaAPI
class
MySuperApi
(
NinjaAPI
):
def
get_openapi_operation_id
(
self
,
operation
):
# here you can access operation ( .path , .view_func, etc)
return
...
api
=
MySuperApi
()
@api
.
get
(
...
)
...
deprecated
Mark an operation as deprecated without removing it by using the
deprecated
argument:
@api
.
post
(
"/make-order/"
,
deprecated
=
True
)
def
some_old_method
(
request
,
order
:
str
):
return
{
"success"
:
True
}
It will be marked as deprecated in the JSON Schema and also in the interactive OpenAPI docs:
include_in_schema
If you need to include/exclude some operation from OpenAPI schema use
include_in_schema
argument:
@api
.
post
(
"/hidden"
,
include_in_schema
=
False
)
def
some_hidden_operation
(
request
):
pass
openapi_extra
You can customize your OpenAPI schema for specific endpoint (detail
OpenAPI Customize Options
)
# You can set requestBody from openapi_extra
@api
.
get
(
"/tasks"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/json"
:
{
"schema"
:
{
"required"
:
[
"email"
],
"type"
:
"object"
,
"properties"
:
{
"name"
:
{
"type"
:
"string"
},
"phone"
:
{
"type"
:
"number"
},
"email"
:
{
"type"
:
"string"
},
},
}
}
},
"required"
:
True
,
}
},
)
def
some_operation
(
request
):
pass
# You can add additional responses to the automatically generated schema
@api
.
post
(
"/tasks"
,
openapi_extra
=
{
"responses"
:
{
400
:
{
"description"
:
"Error Response"
,
},
404
:
{
"description"
:
"Not Found Response"
,
},
},
},
)
def
some_operation_2
(
request
):
pass
Response output options
There are a few arguments that lets you tune response's output:
by_alias
Whether field aliases should be used as keys in the response (defaults to
False
).
exclude_unset
Whether fields that were not set when creating the schema, and have their default values, should be excluded from the response (defaults to
False
).
exclude_defaults
Whether fields which are equal to their default values (whether set or otherwise) should be excluded from the response (defaults to
False
).
exclude_none
Whether fields which are equal to
None
should be excluded from the response (defaults to
False
).
url_name
Allows you to set api endpoint url name (using
django path's naming
)
@api
.
post
(
"/tasks"
,
url_name
=
'tasks'
)
def
some_operation
(
request
):
pass
# then you can get the url with
reverse
(
'api-1.0.0:tasks'
)
See the
Reverse Resolution of URLs
guide for more details.
Specifying servers
If you want to specify single or multiple servers for OpenAPI specification
servers
can be used when initializing NinjaAPI instance:
from
ninja
import
NinjaAPI
api
=
NinjaAPI
(
servers
=
[
{
"url"
:
"https://stag.example.com"
,
"description"
:
"Staging env"
},
{
"url"
:
"https://prod.example.com"
,
"description"
:
"Production env"
},
]
)
This will allow switching between enviroments when using interactive OpenAPI docs:
Previous
CSRF
Next
Management Commands
Made with
Material for MkDocs
----------------------------------------
Title: Management Commands
Content:
Management Commands - Django Ninja
Skip to content
Django Ninja
Management Commands
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Management Commands
Management commands require
Django Ninja
to be installed in Django's
INSTALLED_APPS
setting:
INSTALLED_APPS
=
[
...
'ninja'
,
]
Previous
Operations parameters
Next
Django Settings
Made with
Material for MkDocs
----------------------------------------
Title: Django Settings
Content:
Django Settings - Django Ninja
Skip to content
Django Ninja
Django Settings
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Django Settings
Bases:
BaseModel
Alter these by modifying the values in Django's settings module (usually
settings.py
).
Attributes:
Name
Type
Description
NINJA_PAGINATION_CLASS
str
The pagination class to use. Defaults to
ninja.pagination.LimitOffsetPagination
.
NINJA_PAGINATION_PER_PAGE
int
The default page size. Defaults to
100
.
NINJA_PAGINATION_MAX_LIMIT
int
The maximum number of results per page. Defaults to
inf
.
Previous
Management Commands
Next
Release Notes
Made with
Material for MkDocs
----------------------------------------
Title: Release Notes
Content:
Release Notes - Django Ninja
Skip to content
Django Ninja
Release Notes
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Release Notes
Follow and subscribe for new releases on GitHub:
https://github.com/vitalik/django-ninja/releases
Previous
Django Settings
Next
Help / Get Help
Made with
Material for MkDocs
----------------------------------------
Title: Help / Get Help
Content:
Help / Get Help - Django Ninja
Skip to content
Django Ninja
Help / Get Help
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Help / Get Help
Table of contents
Do you like Django Ninja?
Do you want to help us?
Do you need help?
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Table of contents
Do you like Django Ninja?
Do you want to help us?
Do you need help?
Help / Get Help
Do you like Django Ninja?
If you like this project, there is a tiny thing you can do to let us know that we're moving in the right direction.
Simply give django-ninja a
star on github
or share this URL on social media:
https://django-ninja.dev
Follow updates on twitter
@django_ninja
Do you want to help us?
Pull requests are always welcome.
You can inspect our docs for typos and spelling mistakes, and create pull requests or
open an issue
.
If you have any suggestions to improve
Django Ninja
, please create them as
issues
on GitHub.
Do you need help?
Do not hesitate.  Go to
GitHub issues
and describe your question or problem.  We'll attempt to address them quickly.
Join the chat at our
Discord
server.
Code-on the webdesign and web development company
gives commercial consulting for Django-Ninja. If you are looking for support please contact Code-on and we will be in touch with you soon.
Previous
Release Notes
Next
Intro
Made with
Material for MkDocs
----------------------------------------
Title: Intro
Content:
Intro - Django Ninja
Skip to content
Django Ninja
Intro
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Enhancement Proposals
Enhancement Proposals are a formal way of proposing large feature additions to the
Django Ninja Framework
.
You can create a proposal by making a pull request with a new page under
docs/proposals
, or by creating an
issue on github
.
Please see the current proposals:
Class Based Operations
Previous
Help / Get Help
Next
Class Based Operations
Made with
Material for MkDocs
----------------------------------------
Title: Class Based Operations
Content:
Class Based Operations - Django Ninja
Skip to content
Django Ninja
Class Based Operations
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Class Based Operations
Table of contents
Problem
Solution
Issue
Your thoughts/proposals
Potential v1 changes
What's new in V1
Table of contents
Problem
Solution
Issue
Your thoughts/proposals
Class Based Operations
This is just a proposal and it is
not present in library code
, but eventually this can be a part of Django Ninja.
Please consider adding likes/dislikes or comments in
github issue
to express your feeling about this proposal
Problem
An API operation is a callable which takes a request and parameters and returns a response, but it is often a case in real world when you need to reuse the same pieces of code in multiple operations.
Let's take the following example:
we have a Todo application with Projects and Tasks
each project has multiple tasks
each project may also have an owner (user)
users should not be able to access projects they do not own
Model structure is something like this:
class
Project
(
models
.
Model
):
title
=
models
.
CharField
(
max_length
=
100
)
owner
=
models
.
ForeignKey
(
'auth.User'
,
on_delete
=
models
.
CASCADE
)
class
Task
(
models
.
Model
):
project
=
models
.
ForeignKey
(
Project
,
on_delete
=
models
.
CASCADE
)
title
=
models
.
CharField
(
max_length
=
100
)
completed
=
models
.
BooleanField
()
Now, let's create a few API operations for it:
a list of tasks for the project
some task details
a 'complete task' action
The code should validate that a user can only access his/her own project's tasks (otherwise, return 404)
It can be something like this:
router
=
Router
()
@router
.
get
(
'/project/
{project_id}
/tasks/'
,
response
=
List
[
TaskOut
])
def
task_list
(
request
):
user_projects
=
request
.
user
.
project_set
project
=
get_object_or_404
(
user_projects
,
id
=
project_id
))
return
project
.
task_set
.
all
()
@router
.
get
(
'/project/
{project_id}
/tasks/
{task_id}
/'
,
response
=
TaskOut
)
def
details
(
request
,
task_id
:
int
):
user_projects
=
request
.
user
.
project_set
project
=
get_object_or_404
(
user_projects
,
id
=
project_id
))
user_tasks
=
project
.
task_set
.
all
()
return
get_object_or_404
(
user_tasks
,
id
=
task_id
)
@router
.
post
(
'/project/
{project_id}
/tasks/
{task_id}
/complete'
,
response
=
TaskOut
)
def
complete
(
request
,
task_id
:
int
):
user_projects
=
request
.
user
.
project_set
project
=
get_object_or_404
(
user_projects
,
id
=
project_id
))
user_tasks
=
project
.
task_set
.
all
()
task
=
get_object_or_404
(
user_tasks
,
id
=
task_id
)
task
.
completed
=
True
task
.
save
()
return
task
As you can see, these lines are getting repeated pretty often to check permission:
user_projects
=
request
.
user
.
project_set
project
=
get_object_or_404
(
user_projects
,
id
=
project_id
))
You can extract it to a function, but it will just make it 3 lines smaller, and it will still be pretty polluted ...
Solution
The proposal is to have alternative called "Class Based Operation" where you can decorate the entire class with a
path
decorator:
from
ninja
import
Router
router
=
Router
()
@router
.
path
(
'/project/
{project_id}
/tasks'
)
class
Tasks
:
def
__init__
(
self
,
request
,
project_id
=
int
):
user_projects
=
request
.
user
.
project_set
self
.
project
=
get_object_or_404
(
user_projects
,
id
=
project_id
))
self
.
tasks
=
self
.
project
.
task_set
.
all
()
@router
.
get
(
'/'
,
response
=
List
[
TaskOut
])
def
task_list
(
self
,
request
):
return
self
.
tasks
@router
.
get
(
'/
{task_id}
/'
,
response
=
TaskOut
)
def
details
(
self
,
request
,
task_id
:
int
):
return
get_object_or_404
(
self
.
tasks
,
id
=
task_id
)
@router
.
post
(
'/
{task_id}
/complete'
,
response
=
TaskOut
)
def
complete
(
self
,
request
,
task_id
:
int
):
task
=
get_object_or_404
(
self
.
tasks
,
id
=
task_id
)
task
.
completed
=
True
task
.
save
()
return
task
All common initiation and permission checks are placed in the constructor:
@router
.
path
(
'/project/
{project_id}
/tasks'
)
class
Tasks
:
def
__init__
(
self
,
request
,
project_id
=
int
):
user_projects
=
request
.
user
.
project_set
self
.
project
=
get_object_or_404
(
user_projects
,
id
=
project_id
))
self
.
tasks
=
self
.
project
.
task_set
.
all
()
This makes the main business operation focus only on tasks (exposed as the
self.tasks
attribute)
You can use both
api
and
router
instances to support class paths.
Issue
The
__init__
method:
def __init__(self, request, project_id=int):
Python doesn't support the
async
keyword for
__init__
, so to support async operations we need some other method for initialization, but
__init__
sounds the most logical.
Your thoughts/proposals
Please give you thoughts/likes/dislikes about this proposal in the
github issue
Previous
Intro
Next
Potential v1 changes
Made with
Material for MkDocs
----------------------------------------
Title: Potential v1 changes
Content:
Potential v1 changes - Django Ninja
Skip to content
Django Ninja
Potential v1 changes
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
Potential v1 changes
Table of contents
Changes that most likely be in v1
Your thoughts/proposals
What's new in V1
Table of contents
Changes that most likely be in v1
Your thoughts/proposals
Potential v1 changes
Django Ninja is already used by tens of companies and by the visitors and downloads stats it's growing.
At this point introducing changes that will force current users to change their code (or break it) is not 
acceptable.
On the other hand some decisions that where initially made does not work well. These  breaking changes will be 
introduced in version 1.0.0
Changes that most likely be in v1
auth
will be class interface instead of callable (to support async authenticators)
responses
to support
codes/headers/content
(like general Response class)
routers paths
currently automatically
joined with "/"
- which might not needed on some cases where router prefix will act like a prefix and not subfolder
Your thoughts/proposals
Please give you thoughts/likes/dislikes in the
github issue
.
Previous
Class Based Operations
Next
What's new in V1
Made with
Material for MkDocs
----------------------------------------
Title: What's new in V1
Content:
What's new in V1 - Django Ninja
Skip to content
Django Ninja
What's new in V1
Initializing search
vitalik/django-ninja
Django Ninja
vitalik/django-ninja
Intro
Motivation
Tutorial
Tutorial
First Steps
Parsing Input
Handling Responses
Other Tutorials
Other Tutorials
Video Tutorials
CRUD example
How-to Guides
How-to Guides
Parsing input
Parsing input
HTTP Methods
Path parameters
Query parameters
Request Body
Form data
File uploads
Request parsers
Filtering
Handling responses
Handling responses
Defining a Schema
Altering the Response
Generating a Schema from Django models
Generating a Schema dynamically
Overriding Pydantic Config
Pagination
Response renderers
Splitting your API with Routers
Authentication
Testing
API Docs
Handling errors
Reverse Resolution of URLS
Async support
Versioning
Reference
Reference
NinjaAPI class
CSRF
Operations parameters
Management Commands
Django Settings
Release Notes
Help / Get Help
Enhancement Proposals
Enhancement Proposals
Intro
Class Based Operations
Potential v1 changes
What's new in V1
Welcome to Django Ninja 1.0
To get started install latest version with
pip install -U django-ninja
django-ninja v1 is compatible with Python 3.7 and above.
Django ninja seres 0.x is still supported but will receive only security updates and critical bug fixes
What's new in Django Ninja 1.0
Support for Pydantic2
Pydantic version 2 is re-written in Rust and includes a lot of improvements and features like:
Safer types.
Better extensibility.
Better performance
By our tests average project can gain some 10% performance increase on average, while some edge parsing/serializing cases can give you 4x boost.
On the other hand it introduces breaking changes and pydantic 1 and 2 are not very compatible - but we tried or best to make this transition easy as possible. So if you used 'Schema' class migration to ninja v1 should be easy. Otherwise follow
pydantic migration guide
Some features that are made possible with pydantic2
pydantic context
Pydantic now supports context during validation and serialization and Django ninja passes "request" object during request and response work
class
Payload
(
Schema
):
id
:
int
name
:
str
request_path
:
str
@staticmethod
def
resolve_request_path
(
data
,
context
):
request
=
context
[
"request"
]
return
request
.
get_full_path
()
During response a "response_code" is also passed to context
Schema.Meta
Pydantic now deprecates BaseModel.Config class.  But to keep things consistent with all other django parts we introduce "Meta" class for ModelSchema - which works in a similar way as django's ModelForms:
class
TxItem
(
ModelSchema
):
class
Meta
:
model
=
Transaction
fields
=
[
"id"
,
"account"
,
"amount"
,
"timestamp"
]
(The "Config" class is still supported, but deprecated)
Shorter / cleaner parameters syntax
@api
.
post
(
'/some'
)
def
some_form
(
request
,
username
:
Form
[
str
],
password
:
Form
[
str
]):
return
True
instead of
@api
.
post
(
'/some'
)
def
some_form
(
request
,
username
:
str
=
Form
(
...
),
password
:
str
=
Form
(
...
)):
return
True
or
@api
.
post
(
'/some'
)
def
some_form
(
request
,
data
:
Form
[
AuthSchema
]):
return
True
instead of
@api
.
post
(
'/some'
)
def
some_form
(
request
,
data
:
AuthSchema
=
Form
(
...
)):
return
True
with all the the autocompletion in editors
On the other hand the
old syntax is still supported
so you can easy port your project to a newer django-ninja version without much haste
+ Annotated
typing.Annotated is also supported:
@api
.
get
(
"/annotated"
)
def
annotated
(
request
,
data
:
Annotated
[
SomeData
,
Form
()]):
return
{
"data"
:
data
.
dict
()}
Async auth support
The async authenticators are finally supported. All you have to do is just add
async
to your
authenticate
method:
class
Auth
(
HttpBearer
):
async
def
authenticate
(
self
,
request
,
token
):
await
asyncio
.
sleep
(
1
)
if
token
==
"secret"
:
return
token
Changed CSRF Behavior
csrf=True
requirement is no longer required if you use cookie based authentication. Instead CSRF protection is enabled automatically. This also allow you to  mix csrf-protected authenticators and other methods that does not requrie cookies:
api
=
NinjaAPI
(
auth
=
[
django_auth
,
Auth
()])
Docs
Doc viewer are now configurable and plugable. By default django ninja comes with Swagger and Redoc:
from
ninja
import
NinjaAPI
,
Redoc
,
Swagger
# use redoc
api
=
NinjaAPI
(
docs
=
Redoc
()))
# use swagger:
api
=
NinjaAPI
(
docs
=
Swagger
())
# set configuration for swagger:
api
=
NinjaAPI
(
docs
=
Swagger
({
"persistAuthorization"
:
True
}))
Users now able to create custom docs viewer by inheriting
DocsBase
class
Router
add_router supports string paths:
api
=
NinjaAPI
()
api
.
add_router
(
'/app1'
,
'myproject.app1.router'
)
api
.
add_router
(
'/app2'
,
'myproject.app2.router'
)
api
.
add_router
(
'/app3'
,
'myproject.app3.router'
)
api
.
add_router
(
'/app4'
,
'myproject.app4.router'
)
api
.
add_router
(
'/app5'
,
'myproject.app5.router'
)
Decorators
When django ninja decorates a view with .get/.post etc - it wraps the result of the function (which in most cases are not HttpResponse - but some serializable object) so it's not really possible to use some built-in or 3rd-party decorators like:
from
django.views.decorators.cache
import
cache_page
@api
.
get
(
"/test"
)
@cache_page
(
5
)
# <----- will not work
def
test_view
(
request
):
return
{
"some"
:
"Complex data"
}
This example does not work.
Now django ninja introduces a decorator decorate_view that allows inject decorators that work with http response:
from
ninja.decorators
import
decorate_view
@api
.
get
(
"/test"
)
@decorate_view
(
cache_page
(
5
))
def
test_view
(
request
):
return
str
(
datetime
.
now
())
Paginations
paginate_queryset
method now takes
request
object
Backwards incompatible stuff
resolve_xxx(self, ...) - support resolve with (self) is dropped in favor of pydantic build-in functionality
pydantic v1 is no longer supported
python 3.6 is no longer supported
BTW - if you like this project and still did not give it a github start - please do so
Previous
Potential v1 changes
Made with
Material for MkDocs
----------------------------------------
